import{_ as e,c as i,o as a,a4 as s}from"./chunks/framework.DpC1ZpOZ.js";const g=JSON.parse('{"title":"Redis 单线程模型","description":"","frontmatter":{},"headers":[],"relativePath":"java/Redis/3_单线程模型.md","filePath":"java/Redis/3_单线程模型.md","lastUpdated":null}'),t={name:"java/Redis/3_单线程模型.md"},d=s('<h1 id="redis-单线程模型" tabindex="-1">Redis 单线程模型 <a class="header-anchor" href="#redis-单线程模型" aria-label="Permalink to &quot;Redis 单线程模型&quot;">​</a></h1><h2 id="redis-单线程模型-1" tabindex="-1">Redis 单线程模型 <a class="header-anchor" href="#redis-单线程模型-1" aria-label="Permalink to &quot;Redis 单线程模型&quot;">​</a></h2><p>Redis 基于 Reactor 模式开发了自己的网络事件处理器，这个处理器被称为文件事件处理器（file event handler）。由于文件事件处理器（file event handler）是单线程方式运行的，所以说 Redis 是单线程模型。</p><p>虽然 Redis 是单线程的，但仍然可以监听大量的客户端连接，原因在于文件事件处理器使用 <strong>I/O 多路复用（multiplexing）程序</strong>来同时监听多个客户端连接（即多个套接字），并根据套接字目前执行的任务来为套接字关联不同的事件处理器。也就是说，<strong>I/O 多路复用技术使得 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong>。</p><h3 id="i-o-多路复用" tabindex="-1">I/O 多路复用 <a class="header-anchor" href="#i-o-多路复用" aria-label="Permalink to &quot;I/O 多路复用&quot;">​</a></h3><p>多路指的是多个 Socke t连接，复用指的是复用一个线程。</p><p>多路复用主要有三种技术：select，poll，epoll。epoll 是最新的也是目前最好的多路复用技术。</p><div align="center"><img src="https://github.com/DuHouAn/ImagePro/raw/master/redis/r_2.png" width="700px"></div><h3 id="文件事件处理器" tabindex="-1">文件事件处理器 <a class="header-anchor" href="#文件事件处理器" aria-label="Permalink to &quot;文件事件处理器&quot;">​</a></h3><p>Redis 服务器是一个事件驱动程序。服务器需要处理两类事件：</p><ul><li>文件事件：服务器通过套接字与客户端或者其它服务器进行通信，<strong>文件事件就是对套接字操作的抽象</strong>。</li><li>时间事件：服务器有一些操作需要在给定的时间点执行，时间事件是对这类定时操作的抽象。</li></ul><p>文件事件处理器主要是包含 4 个部分：</p><ul><li>多个 Socket（客户端连接）</li><li>IO 多路复用程序（支持多个客户端连接）</li><li>文件事件分派器（将 Socket 关联到相应的事件处理器）</li><li>事件处理器（比如命令请求处理器、命令回复处理器、连接应答处理器）</li></ul><p>Redis 选择使用单线程模型处理来自客户端的绝大多数网络请求，主要有以下 3 个原因：</p><ul><li><p>几乎不存在 CPU 成为瓶颈的情况， Redis 主要受限于内存和网络。</p><p>Redis 并不是 CPU 密集型的服务，如果不开启 AOF 备份，所有 Redis 的操作都会在内存中完成不会涉及任何的 I/O 操作，这些<strong>数据的读写由于只发生在内存中</strong>，所以处理速度是非常快的；</p><p>整个服务的瓶颈在于<strong>网络传输带来的延迟</strong>和<strong>等待客户端的数据传输</strong>，也就是网络 I/O，所以使用多线程模型处理全部的外部请求可能不是一个好的方案。</p></li><li><p>使用单线程模型能带来更好的可维护性，方便开发和调试</p><p>单线程不需要并发控制。</p></li><li><p>使用单线程模型也能并发的处理客户端的请求</p><p>I/O 多路复用机制。</p></li></ul><h2 id="redis-4-0-后引入多线程" tabindex="-1">Redis 4.0 后引入多线程 <a class="header-anchor" href="#redis-4-0-后引入多线程" aria-label="Permalink to &quot;Redis 4.0 后引入多线程&quot;">​</a></h2><p>在 Redis 4.0 之后的版本，Redis 服务在执行一些命令时就会使用 ”主处理线程“ 之外的其他线程，例如 <code>UNLINK</code>、<code>FLUSHALL ASYNC</code>、<code>FLUSHDB ASYNC</code> 等非阻塞的删除操作。</p><p>对于 Redis 中的一些超大键值对，几十 MB 或者几百 MB 的数据并不能在几毫秒的时间内处理完，Redis 可能会需要在释放内存空间上消耗较多的时间。其实释放内存空间的工作可以由后台线程异步进行处理，只需要将键从元数据中删除，而真正的删除操作会在后台异步执行。Redis 引入多线程后，对于一些<strong>大键值对的删除操作</strong>，可以通过<strong>多线程非阻塞地释放内存空间</strong>减少对 Redis 主线程阻塞的时间，提高执行的效率。</p><p>总的来说，<strong>Redis 6.0 之前主要还是单线程处理</strong>。</p><h2 id="redis-6-0-引入多线程" tabindex="-1">Redis 6.0 引入多线程 <a class="header-anchor" href="#redis-6-0-引入多线程" aria-label="Permalink to &quot;Redis 6.0 引入多线程&quot;">​</a></h2><p>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能。</p><p>虽然 Redis6.0 引入了多线程，但是 Redis 的多线程只是在<strong>网络数据的读写这类耗时操作上使用</strong>，执行命令仍然是单线程顺序执行。所以仍然是线程安全的。</p><p>Redis 6.0 的多线程默认是禁用的，只使用主线程。如需开启需要修改 redis.conf 配置文件：</p><div class="language-html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">io-threads-do-reads yes # 开启多线程</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>开启多线程后，还需要设置线程数，否则是不生效的。同样需要修改 redis.conf 配置文件：</p><div class="language-html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">io-threads 2 # 官网建议 4 核的机器建议设置为2或3个线程，8 核的建议设置为6个线程</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>关于线程数，官方有一个建议：4 核的机器建议设置为 2 或 3 个线程，8 核的建议设置为 6个线程，线程数一定要小于机器核数。</p><h3 id="redis-6-0-多线程的实现机制" tabindex="-1">Redis 6.0 多线程的实现机制 <a class="header-anchor" href="#redis-6-0-多线程的实现机制" aria-label="Permalink to &quot;Redis 6.0 多线程的实现机制&quot;">​</a></h3><p>实现机制流程如下：</p><ul><li>主线程负责接收建立连接请求，获取 Socket 放入等待队列</li><li>主线程处理完读事件之后，通过轮询调度方法将这些连接分配给这些 IO 线程</li><li>主线程阻塞等待 IO 线程读取 Socket 完毕</li><li>主线程执行请求命令，请求数据读取并解析完成</li><li>主线程阻塞等待 IO 线程将数据回写 Socket 完毕</li><li>解除绑定，清空等待队列</li></ul><p>其中 IO 线程：</p><ul><li>要么同时在读 Socket，要么同时在写，不会同时读或写</li><li>只负责读写 Socket 解析命令，不负责命令处理</li></ul><div align="center"><img src="https://github.com/DuHouAn/ImagePro/raw/master/redis/redis_11.png"></div><h3 id="redis-6-0-多线程和-memcached-多线程模型对比" tabindex="-1">Redis 6.0 多线程和 Memcached 多线程模型对比 <a class="header-anchor" href="#redis-6-0-多线程和-memcached-多线程模型对比" aria-label="Permalink to &quot;Redis 6.0 多线程和 Memcached 多线程模型对比&quot;">​</a></h3><p>相同点：都采用了 Master 线程-Worker 线程模型</p><p>不同点：Memcached 执行主逻辑也是在 Worker 线程里，模型更加简单，实现了真正的线程隔离，符合我们对线程隔离的常规理解。而 Redis 把处理逻辑交还给 Master 线程，虽然一定程度上增加了模型复杂度，但也解决了线程并发安全等问题。</p>',36),r=[d];function l(o,n,p,c,h,u){return a(),i("div",null,r)}const R=e(t,[["render",l]]);export{g as __pageData,R as default};
