import{_ as s,c as a,o as i,a4 as n}from"./chunks/framework.DpC1ZpOZ.js";const g=JSON.parse('{"title":"Lock 体系","description":"","frontmatter":{},"headers":[],"relativePath":"java/Java_Concurrency/4_Lock 体系.md","filePath":"java/Java_Concurrency/4_Lock 体系.md","lastUpdated":1728037326000}'),t={name:"java/Java_Concurrency/4_Lock 体系.md"},l=n(`<h1 id="lock-体系" tabindex="-1">Lock 体系 <a class="header-anchor" href="#lock-体系" aria-label="Permalink to &quot;Lock 体系&quot;">​</a></h1><h2 id="aqs" tabindex="-1">AQS <a class="header-anchor" href="#aqs" aria-label="Permalink to &quot;AQS&quot;">​</a></h2><p>AQS(AbtsractQueueSynchronized) 即同步队列器。</p><p>AQS 是一个<strong>抽象类</strong>，本身并没有实现任何同步接口的，只是通过提供<strong>同步状态的获取和释放</strong>来供自定义的同步组件使用。</p><p>AQS 的实现依赖内部的双向队列（底层是双向链表），称为同步队列。</p><p>如果当前线程获取同步状态失败，则会将该线程以及等待状态等信息封装为 Node，将其<strong>加入同步队列的尾部，同时阻塞当前线程</strong>，当同步状态释放时，唤醒队列的头结点。</p><p>AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> transient</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> volatile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Node head; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//同步队列的头结点</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> transient</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> volatile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Node tail; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//同步队列的尾结点</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> volatile</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> state; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//同步状态。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// state=0，表示同步状态可用</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// state=1，表示同步状态已被占用</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>补充：<a href="https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html" target="_blank" rel="noreferrer">AQS详解</a></p><h2 id="condition-条件对象" tabindex="-1">Condition 条件对象 <a class="header-anchor" href="#condition-条件对象" aria-label="Permalink to &quot;Condition 条件对象&quot;">​</a></h2><p>条件对象是<strong>线程同步对象中的一种</strong>，主要用来等待某种条件的发生，条件发生后，可以唤醒等待在该条件上的一个线程或者所有线程。</p><p><strong>条件对象要与锁一起协同工作</strong>。通过 ReentrantLock 的 newCondtion 获取实例对象。</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ReentrantLock lock </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ReentrantLock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Condition condition </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lock.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">newCondition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Condition 中有 awai()、signal()、signalAll() 方法，分别对应 Object 中放入 wait()、notify()、notifyAll() 方法，其实 Condition 也有上述三种方法，改变方法名称是为了避免使用上语义的混淆。</p><p>补充：<a href="https://blog.csdn.net/qq_38293564/article/details/80554516" target="_blank" rel="noreferrer">Condition 详解</a></p><h2 id="可重入" tabindex="-1">可重入 <a class="header-anchor" href="#可重入" aria-label="Permalink to &quot;可重入&quot;">​</a></h2><p>某个线程试图获取一个已经由该线程持有的锁，那么这个请求就会成功。“重入”意味着获取的锁的操作的粒度是“线程”而不是“调用”。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。</p><p>重入的一种实现方法是：为每个锁关联一个<strong>计数器</strong>（方便解锁）和一个<strong>所有者线程</strong>（知道是哪个线程是可重入的），同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。</p><h2 id="公平锁与非公平锁" tabindex="-1">公平锁与非公平锁 <a class="header-anchor" href="#公平锁与非公平锁" aria-label="Permalink to &quot;公平锁与非公平锁&quot;">​</a></h2><p>公平锁是指多个线程在等待同一个锁时，<strong>按照申请锁的顺序来依次获取锁</strong>。</p><h3 id="公平锁" tabindex="-1">公平锁 <a class="header-anchor" href="#公平锁" aria-label="Permalink to &quot;公平锁&quot;">​</a></h3><ul><li><p>公平锁每次获取到锁为同步队列中的第一个节点，保证请求资源时间上的绝对顺序。</p></li><li><p>公平锁为了保证时间上的绝对顺序，需要频繁的上下文切换，性能较差</p></li></ul><h3 id="非公平锁" tabindex="-1">非公平锁 <a class="header-anchor" href="#非公平锁" aria-label="Permalink to &quot;非公平锁&quot;">​</a></h3><ul><li><p>非公平锁有可能刚释放锁的线程下次继续获取该锁，则有可能导致其他线程永远无法获取到锁，造成 “饥饿” 现象。</p></li><li><p>非公平锁会<strong>降低一定的上下文切换</strong>，降低性能开销。<strong>ReentrantLock 默认选择的是非公平锁</strong>。</p></li></ul><h2 id="独占锁和共享锁" tabindex="-1">独占锁和共享锁 <a class="header-anchor" href="#独占锁和共享锁" aria-label="Permalink to &quot;独占锁和共享锁&quot;">​</a></h2><h3 id="独占锁" tabindex="-1">独占锁 <a class="header-anchor" href="#独占锁" aria-label="Permalink to &quot;独占锁&quot;">​</a></h3><ul><li>独占锁模式下，每次只能有一个线程能持有锁，ReentrantLock 就是以独占方式实现的互斥锁。</li><li>独占锁是一种悲观保守的加锁策略，它<strong>避免了读/读冲突</strong>，如果某个只读线程获取锁，则其他读线程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。</li></ul><h3 id="共享锁" tabindex="-1">共享锁 <a class="header-anchor" href="#共享锁" aria-label="Permalink to &quot;共享锁&quot;">​</a></h3><ul><li>共享锁允许多个线程同时获取锁，并发访问共享资源，如：ReadWriteLock。</li><li>共享锁则是一种乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。</li></ul><h2 id="reentrantlock" tabindex="-1">ReentrantLock <a class="header-anchor" href="#reentrantlock" aria-label="Permalink to &quot;ReentrantLock&quot;">​</a></h2><p>ReentrantLock 即可重入锁，有 3 个内部类：Sync、FairSync 和 NonfairSync。</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">abstract</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Sync</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AbstractQueuedSynchronizer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> final</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FairSync</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Sync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> final</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> NonfairSync</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Sync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><ul><li><p>Sync 是一个继承 AQS 的抽象类，并重写了 tryRelease() 方法，并发控制就是通过 Sync 实现的。</p><p>此外 Sync 还有两个子类 FiarSync 和 NonfairSync，即公平锁和非公平锁。</p></li><li><p>由于 Sync 重写 tryRealese() 方法，并且 FairSync 和 NonfairSync 没有再次重写该方法，所以<strong>公平锁和非公平锁释放锁的操作是一样的</strong>，即<strong>唤醒等待队列中第一个被挂起的线程</strong>。</p></li><li><p>公平锁和非公平锁获取锁的方式是不同的。</p><p>公平锁获取锁时，如果一个线程已经获取了锁，其他线程都会被挂起进入等待队列，后面来的<strong>线程等待的时间</strong>没有等待队列中线程等待的时间长的话，那么就会放弃获取锁，直接进入等待队列；</p><p>非公平锁获取锁的方式是一种<strong>抢占式</strong>的，不考虑线程等待时间，无论是哪个线程获取了锁，则其他线程就进入等待队列。</p></li><li><p>ReentrantLock 默认选择的是非公平锁。</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> final</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Sync sync;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ReentrantLock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 默认是非公平锁</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    sync </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> NonfairSync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ReentrantLock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fair) { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 可设置为公平锁</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    sync </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fair </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FairSync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> NonfairSync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li></ul><h2 id="reentrantlock-与-synchronized-的区别" tabindex="-1">ReentrantLock 与 synchronized 的区别 <a class="header-anchor" href="#reentrantlock-与-synchronized-的区别" aria-label="Permalink to &quot;ReentrantLock 与 synchronized 的区别&quot;">​</a></h2><ul><li><p><strong>锁的实现</strong>：</p><p>synchronized 是 JVM 实现的，ReentrantLock 是 JDK 实现的。</p></li><li><p><strong>性能</strong>：</p><p>JDK1.6 后对 synchronized 进行了很多优化，两者的性能大致相同。</p></li><li><p><strong>等待可中断</strong>：</p><p>当持有锁的线程长期未释放锁时，正在等待的线程可选择放弃等待，改为处理其他事情。</p><p>ReentrantLock 是等待可中断的，synchronized 则不行。</p></li><li><p><strong>公平锁</strong>：</p><p>公平锁是指多个线程在等待同一个锁时，<strong>按照申请锁的顺序来依次获取锁</strong>。</p><p>synchronized 默认是非公平锁，ReentrantLock 既可以是公平锁，又可以是非公平锁。</p></li><li><p><strong>锁绑定多个条件</strong>：</p><p>一个 ReentrantLock 可以绑定多个 Condition 对象。</p></li></ul><h2 id="locksupport" tabindex="-1">LockSupport <a class="header-anchor" href="#locksupport" aria-label="Permalink to &quot;LockSupport&quot;">​</a></h2><p>LockSupport 位于 java.util.concurrent.locks 包下。</p><p>LockSupprot 是线程的<strong>阻塞原语</strong>，用来<strong>阻塞线程</strong>和<strong>唤醒线程</strong>。</p><p>每个使用 LockSupport 的线程都会与一个许可关联， 如果该许可可用，并且可在线程中使用，则调用 park() 将会立即返回，否则可能阻塞。 如果许可尚不可用，则可以调用 unpark() 方法使其可用。</p><p>但是注意<strong>许可不可重入</strong>，也就是说只能调用一次 park() 方法，否则会一直阻塞。</p><h3 id="成员方法" tabindex="-1">成员方法 <a class="header-anchor" href="#成员方法" aria-label="Permalink to &quot;成员方法&quot;">​</a></h3><table tabindex="0"><thead><tr><th style="text-align:center;">方法</th><th style="text-align:center;">说明</th></tr></thead><tbody><tr><td style="text-align:center;">void park()</td><td style="text-align:center;">阻塞当前线程，如果调用 unpark() 方法或者当前线程被中断， 能从 park()方法中返回</td></tr><tr><td style="text-align:center;">void park(Object blocker)</td><td style="text-align:center;">功能同park()，入参增加一个Object对象，用来记录导致线程阻塞的阻塞对象，方便进行问题排查</td></tr><tr><td style="text-align:center;">void parkNanos(long nanos)</td><td style="text-align:center;">阻塞当前线程，最长不超过nanos纳秒，增加了超时返回的特性</td></tr><tr><td style="text-align:center;">void parkNanos(Object blocker, long nanos)</td><td style="text-align:center;">功能同 parkNanos(long nanos)，入参增加一个 Object 对象，用来记录导致线程阻塞的阻塞对象，方便进行问题排查</td></tr><tr><td style="text-align:center;">void parkUntil(long deadline)</td><td style="text-align:center;">阻塞当前线程，deadline 已知</td></tr><tr><td style="text-align:center;">void parkUntil(Object blocker, long deadline)</td><td style="text-align:center;">功能同 parkUntil(long deadline)，入参增加一个 Object 对象，用来记录导致线程阻塞的阻塞对象，方便进行问题排查</td></tr><tr><td style="text-align:center;">void unpark(Thread thread)</td><td style="text-align:center;">唤醒处于阻塞状态的指定线程</td></tr></tbody></table><p>实际上 LockSupport 阻塞和唤醒线程的功能是<strong>依赖于 sun.misc.Unsafe</strong>，比如 park() 方法的功能实现则是靠unsafe.park() 方法。 另外在阻塞线程这一系列方法中还有一个很有意思的现象：每个方法都会新增一个带有Object 的阻塞对象的重载方法。 那么增加了一个 Object 对象的入参会有什么不同的地方了？</p><ul><li>调用 park() 方法 dump 线程：</li></ul><div class="language-html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&quot;main&quot; #1 prio=5 os_prio=0 tid=0x02cdcc00 nid=0x2b48 waiting on condition [0x00d6f000]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   java.lang.Thread.State: WAITING (parking)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        at sun.misc.Unsafe.park(Native Method)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:304)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        at learn.LockSupportDemo.main(LockSupportDemo.java:7)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li>调用 park(Object blocker) 方法 dump 线程:</li></ul><div class="language-html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&quot;main&quot; #1 prio=5 os_prio=0 tid=0x0069cc00 nid=0x6c0 waiting on condition [0x00dcf000]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   java.lang.Thread.State: WAITING (parking)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        at sun.misc.Unsafe.park(Native Method)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        - parking to wait for  &lt;</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">0x048c2d18</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; (a java.lang.String)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        at learn.LockSupportDemo.main(LockSupportDemo.java:7)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>通过分别调用这两个方法然后 dump 线程信息可以看出， 带 Object 的 park 方法相较于无参的 park 方法会增加</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> parking to wait </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0x048c2d18</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (a java.lang.String)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这种信息就类似于记录“案发现场”，有助于工程人员能够迅速发现问题解决问题。</p><p>注意：</p><ul><li>synchronized 使线程阻塞，线程会进入到 Blocked 状态（阻塞状态）</li><li>调用 LockSupport 方法阻塞线程会使线程进入到 Waiting 状态（等待状态）</li></ul><h3 id="使用示例" tabindex="-1">使用示例 <a class="header-anchor" href="#使用示例" aria-label="Permalink to &quot;使用示例&quot;">​</a></h3><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> java.util.concurrent.locks.LockSupport;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> LockSupportExample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Thread t1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Thread</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            LockSupport.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">park</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Thread.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">currentThread</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;被唤醒&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Thread t2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Thread</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            LockSupport.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">park</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Thread.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">currentThread</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;被唤醒&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        t1.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">start</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        t2.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">start</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            Thread.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sleep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (InterruptedException </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            e.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">printStackTrace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        LockSupport.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">unpark</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(t1);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        LockSupport.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">unpark</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(t2);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><div class="language-html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Thread-0被唤醒</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Thread-1被唤醒</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>t1 线程调用 LockSupport.park() 使 t1 阻塞， 当 mian 线程睡眠 3 秒结束后通过 LockSupport.unpark(t1)方法唤醒 t1 线程，t1 线程被唤醒执行后续操作。 另外，还有一点值得关注的是，LockSupport.unpark(t1)可以<strong>通过指定线程对象唤醒指定的线程</strong>。</p>`,56),e=[l];function p(h,r,k,d,c,o){return i(),a("div",null,e)}const y=s(t,[["render",p]]);export{g as __pageData,y as default};
