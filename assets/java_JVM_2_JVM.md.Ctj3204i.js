import{_ as t,c as e,o as r,a4 as a}from"./chunks/framework.DpC1ZpOZ.js";const u=JSON.parse('{"title":"HotSpot 虚拟机对象","description":"","frontmatter":{},"headers":[],"relativePath":"java/JVM/2_JVM.md","filePath":"java/JVM/2_JVM.md","lastUpdated":1728037326000}'),n={name:"java/JVM/2_JVM.md"},o=a('<h1 id="hotspot-虚拟机对象" tabindex="-1">HotSpot 虚拟机对象 <a class="header-anchor" href="#hotspot-虚拟机对象" aria-label="Permalink to &quot;HotSpot 虚拟机对象&quot;">​</a></h1><h2 id="对象的创建" tabindex="-1">对象的创建 <a class="header-anchor" href="#对象的创建" aria-label="Permalink to &quot;对象的创建&quot;">​</a></h2><p>对象的创建步骤：</p><div align="center"><img src="https://gitee.com/duhouan/ImagePro/raw/master/JVM/j_4.jpg"></div><ol><li><strong>类加载检查</strong></li></ol><p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的<strong>符号引用</strong>， 并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。 如果没有，那必须先执行相应的类加载过程。</p><ol start="2"><li><strong>分配内存</strong></li></ol><p>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。 对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择那种分配方式由 Java 堆是否规整决定， 而Java堆是否规整又由所采用的<strong>垃圾收集器是否带有压缩整理功能</strong>决定。</p><ul><li>内存分配的两种方式</li></ul><table tabindex="0"><thead><tr><th style="text-align:center;">内存分配的两种方式</th><th style="text-align:center;"><strong>指针碰撞</strong></th><th style="text-align:center;"><strong>空闲列表</strong></th></tr></thead><tbody><tr><td style="text-align:center;">适用场景</td><td style="text-align:center;">堆内存规整(即没有内存碎片)的情况</td><td style="text-align:center;">堆内存不规整的情况</td></tr><tr><td style="text-align:center;">原理</td><td style="text-align:center;">用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界值指针，只需要向着没用过的内存方向将指针移动一段与对象大小相等的距离</td><td style="text-align:center;">虚拟机会维护一个列表，在该列表和总分记录哪些内存块是可用的，在分配的时候，找一块足够大的内存块划分给对象示例，然后更新列表记录</td></tr><tr><td style="text-align:center;">GC收集器</td><td style="text-align:center;">Serial ParNew</td><td style="text-align:center;">CMS</td></tr></tbody></table><ul><li>内存分配并发问题</li></ul><p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情， 作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p><p>(1)CAS+失败重试： CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。</p><p>(2)TLAB: 每一个线程预先在Java堆中分配一块内存，称为本地线程分配缓冲(Thread Local Allocation Buffer,TLAB)。哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才采用上述的CAS进行内存分配。</p><ol start="3"><li><strong>初始化零值</strong></li></ol><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作<strong>保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用</strong>，程序能访问到这些字段的数据类型所对应的零值。</p><ol start="4"><li><strong>设置对象头</strong></li></ol><p>初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><ol start="5"><li><strong>执行init方法</strong></li></ol><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了， 但从 Java 程序的视角来看，对象创建才刚开始，<strong>&lt;init&gt; 方法还没有执行，所有的字段都还为零</strong>。 所以一般来说，执行 new 指令之后会接着执行 &lt;init &gt; 方法， 把<strong>对象按照程序员的意愿进行初始化</strong>，这样一个真正可用的对象才算完全产生出来。</p><h2 id="对象的内存布局" tabindex="-1">对象的内存布局 <a class="header-anchor" href="#对象的内存布局" aria-label="Permalink to &quot;对象的内存布局&quot;">​</a></h2><p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：对象头、实例数据、对齐填充。</p><div align="center"><img src="https://gitee.com/duhouan/ImagePro/raw/master/JVM/j_5.png"></div><ul><li><strong>对象头</strong></li></ul><p>Hotspot虚拟机的对象头包括两部分信息：</p><p>一部分用于存储对象自身的运行时数据（哈希码、GC分代年龄、锁状态标志等等），</p><p>另一部分是类型指针，即对象指向它的<strong>类元数据的指针</strong>，虚拟机通过这个指针来<strong>确定这个对象是哪个类的实例</strong>。</p><ul><li><strong>实例数据</strong></li></ul><p>实例数据部分是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。</p><ul><li><strong>对齐填充</strong></li></ul><p>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起<strong>占位</strong>作用。 因为Hotspot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍， 换句话说就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或2倍）， 因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><h2 id="对象的访问定位" tabindex="-1">对象的访问定位 <a class="header-anchor" href="#对象的访问定位" aria-label="Permalink to &quot;对象的访问定位&quot;">​</a></h2><p>建立对象就是为了使用对象，我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。 对象的访问方式视虚拟机的实现而定，目前主流的访问方式有两种：使用句柄、直接指针。</p><ul><li><strong>使用句柄</strong></li></ul><p>如果使用<a href="https://zh.wikipedia.org/wiki/%E5%8F%A5%E6%9F%84" target="_blank" rel="noreferrer">句柄</a>的话，那么 <strong>Java 堆</strong>中将会划分出一块内存来作为句柄池，reference 中存储的就是<strong>对象的句柄地址</strong>，而句柄中包含了对象实例数据与类型数据各自的具体地址信息 。</p><div align="center"><img src="https://gitee.com/duhouan/ImagePro/raw/master/JVM/j_6.png"></div><ul><li><strong>直接指针</strong></li></ul><p>如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是<strong>对象的地址</strong>。</p><div align="center"><img src="https://gitee.com/duhouan/ImagePro/raw/master/JVM/j_7.png"></div><p>这两种对象访问方式各有优势:</p><p>1、使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而<strong>reference本身不需要修改</strong>。</p><p>2、使用直接指针访问方式最大的好处就是<strong>速度快</strong>，它节省了一次指针定位的时间开销。</p>',42),s=[o];function l(i,g,p,d,c,h){return r(),e("div",null,s)}const m=t(n,[["render",l]]);export{u as __pageData,m as default};
