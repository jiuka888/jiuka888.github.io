import{_ as e,c as a,o as s,a4 as t}from"./chunks/framework.DpC1ZpOZ.js";const g=JSON.parse('{"title":"Redis 持久化机制","description":"","frontmatter":{},"headers":[],"relativePath":"java/Redis/5_持久化机制.md","filePath":"java/Redis/5_持久化机制.md","lastUpdated":null}'),n={name:"java/Redis/5_持久化机制.md"},i=t(`<h1 id="redis-持久化机制" tabindex="-1">Redis 持久化机制 <a class="header-anchor" href="#redis-持久化机制" aria-label="Permalink to &quot;Redis 持久化机制&quot;">​</a></h1><p>持久化数据是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置</p><p>Redis 是内存型数据库，支持将内存中数据持久化到磁盘。一方面，可保证数据断电后不丢失，另一方面，保存中间结果，不必重新计算。</p><p>Redis 支持 2 种持久化：</p><ul><li>RDB (redis database) 持久化</li><li>AOF (append only file) 持久化</li></ul><h2 id="rdb-持久化" tabindex="-1">RDB 持久化 <a class="header-anchor" href="#rdb-持久化" aria-label="Permalink to &quot;RDB 持久化&quot;">​</a></h2><p>RDB 持久化即快照持久化，通过创建<strong>快照</strong>来获得 Redis 存储在内存中数据在某个时间点上的副本。在创建快照后，用户可对快照备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本，还可以将快照留在原地以便重启服务器的时候使用。</p><h3 id="rdb-持久化配置" tabindex="-1">RDB 持久化配置 <a class="header-anchor" href="#rdb-持久化配置" aria-label="Permalink to &quot;RDB 持久化配置&quot;">​</a></h3><p>快照持久化是 Redis 默认采用的持久化方式，可在 Redis.conf 文件中进行配置：</p><div class="language-html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">save 60 1 </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"># 在60秒(1分钟)之后，如果至少有1个键发生变化，Redis 就会自动触发 BGSAVE 命令创建快照。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">stop-writes-on-bgsave-error yes </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"># 表示备份进程出错的时候，主进程就停止接收新的写入操作，是为了保护持久化数据的一致性。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">rdbcompression no</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"># RDB 的压缩设置为 no，因为压缩会占用更多的 CPU 资源</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="bgavse-命令" tabindex="-1">BGAVSE 命令 <a class="header-anchor" href="#bgavse-命令" aria-label="Permalink to &quot;BGAVSE 命令&quot;">​</a></h3><p>客户端向 Redis 发送 BGSAVE 命令来<strong>创建一个快照</strong>。对于支持 BGSAVE 命令的平台来说（基本上所有平台支持，除了 Windows 平台），<strong>Redis 会调用 fork 来创建一个子进程，然后子进程负责将快照写入硬盘，而主进程则继续处理命令请求</strong>。</p><p>对于如下命令：</p><div class="language-html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">save 60 10000</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>表示从 <strong>Redis 最近一次创建快照之后</strong>算起，满足 “60 s 内 10000 次写入”，Redis 会自动触发 BGSAVE 命令。</p><h2 id="aof-持久化" tabindex="-1">AOF 持久化 <a class="header-anchor" href="#aof-持久化" aria-label="Permalink to &quot;AOF 持久化&quot;">​</a></h2><p>AOF 持久化将被执行的写命令写到 AOF 文件末尾，记录数据发生的变化。</p><p>Redis 值只要从头到尾重新执行一次 AOF 文件包含的所有写命令，就可恢复 AOF 文件所记录的数据。</p><p>默认情况下，Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启：</p><div class="language-html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">appendonly yes</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="aof-持久化配置" tabindex="-1">AOF 持久化配置 <a class="header-anchor" href="#aof-持久化配置" aria-label="Permalink to &quot;AOF 持久化配置&quot;">​</a></h3><div class="language-html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">appendfsync always # 同步选项</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">auto-aof-rewrite-percentage 100</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">auto-aof-rewrite-min-size 64mb</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="同步选项" tabindex="-1">同步选项 <a class="header-anchor" href="#同步选项" aria-label="Permalink to &quot;同步选项&quot;">​</a></h3><p>使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。</p><p>这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项：</p><table tabindex="0"><thead><tr><th style="text-align:center;">同步选项</th><th style="text-align:center;">同步频率</th><th style="text-align:center;">说明</th></tr></thead><tbody><tr><td style="text-align:center;">always</td><td style="text-align:center;">每个 Redis 写命令都要同步写入磁盘</td><td style="text-align:center;">当系统发生崩溃时，丢失的数据减到最少;<br>需要对磁盘大量写入，速度会受到磁盘限制</td></tr><tr><td style="text-align:center;">everysec</td><td style="text-align:center;">每秒执行一次同步，显示地将多个写命令同步到磁盘</td><td style="text-align:center;">性能上和不使用任何持久化特性时相差无几，<br>可保证数据即使出现系统崩溃，用户也最多只会丢失 1 秒内产生的数据</td></tr><tr><td style="text-align:center;">no</td><td style="text-align:center;">由操作系统来决定何时进行同步</td><td style="text-align:center;">不会对 Redis 性能产生影响，但系统崩溃将导致 Redis 丢失不定量的数据，<br>若用户写入磁盘处理写入速度不够快，当缓冲区被等待写入磁盘的数据填满时，Redis 写入操作会被阻塞，并导致 Redis 处理命令请求变慢</td></tr></tbody></table><h3 id="重写-压缩-aof" tabindex="-1">重写/压缩 AOF <a class="header-anchor" href="#重写-压缩-aof" aria-label="Permalink to &quot;重写/压缩 AOF&quot;">​</a></h3><p>AOF 持久化存在的问题：</p><ul><li>随着 Redis 不断运行，AOF 文件的体积会不断增长，占用更多的磁盘空间</li><li>若 AOF 文件体积非常大，则恢复的时间可能会比较长</li></ul><p>为了解决 AOF 文件不断增大的问题，我们采用重写/压缩 AOF 文件的方式：</p><p>用户发送 BGREWRITEAOF 命令，通过<strong>移除 AOF 文件中冗余命令</strong>来重写 AOF 文件来减小 AOF 文件的体积。也就是说，AOF 重写产生了一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。</p><p>BGREWRITEAOF 原理：</p><div align="center"><img src="https://github.com/DuHouAn/ImagePro/raw/master/redis/r_4.png" width="700px"></div><p>Redis 维护一个 AOF 重写缓冲区（aof_rewrite_buf）。在子进程创建新的 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新旧两个 AOF 文件所保存的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。</p><h2 id="rdb-和-aof-对比" tabindex="-1">RDB 和 AOF 对比 <a class="header-anchor" href="#rdb-和-aof-对比" aria-label="Permalink to &quot;RDB 和 AOF 对比&quot;">​</a></h2><table tabindex="0"><thead><tr><th style="text-align:center;">持久化方式</th><th style="text-align:center;">优点</th><th style="text-align:center;">缺点</th></tr></thead><tbody><tr><td style="text-align:center;">RDB</td><td style="text-align:center;">文件小，恢复快</td><td style="text-align:center;">如果系统发生故障，会丢失最近一次生成快照后写入的数据；<br>是压缩文件，可读性较差</td></tr><tr><td style="text-align:center;">AOF</td><td style="text-align:center;">可读性好；<br>数据不易丢失（丢失 1 秒内产生的数据）</td><td style="text-align:center;">文件体积大，占用磁盘空间；<br>恢复时间长</td></tr></tbody></table><h2 id="redis-4-0-优化" tabindex="-1">Redis 4.0 优化 <a class="header-anchor" href="#redis-4-0-优化" aria-label="Permalink to &quot;Redis 4.0 优化&quot;">​</a></h2><p>Redis 4.0 开始支持 RDB和 AOF 的混合持久化。默认是关闭的，需要配置：</p><div class="language-html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">aof-user-rdb-preamble yes</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。</p>`,40),l=[i];function r(d,p,h,o,c,b){return s(),a("div",null,l)}const m=e(n,[["render",r]]);export{g as __pageData,m as default};
