import{_ as s,c as a,o as i,a4 as e}from"./chunks/framework.DpC1ZpOZ.js";const g=JSON.parse('{"title":"Spring 概述","description":"","frontmatter":{},"headers":[],"relativePath":"java/Spring/1_Spring概述.md","filePath":"java/Spring/1_Spring概述.md","lastUpdated":null}'),n={name:"java/Spring/1_Spring概述.md"},p=e(`<h1 id="spring-概述" tabindex="-1">Spring 概述 <a class="header-anchor" href="#spring-概述" aria-label="Permalink to &quot;Spring 概述&quot;">​</a></h1><h2 id="spring-的特性" tabindex="-1">Spring 的特性 <a class="header-anchor" href="#spring-的特性" aria-label="Permalink to &quot;Spring 的特性&quot;">​</a></h2><p>Spring 基于 J2EE 技术实现了一套<strong>轻量级</strong>的 Java Web Service 系统应用框架，旨在提高开发人员的开发效率以及系统的可维护性。Spring 的特性包括：</p><ul><li><p>轻量级</p><p>从 Jar 包的大小上来说，核心 Jar 包 <code>spring-web-5.2.0.RELEASE.jar</code>和 <code>spring-core-5.2.0.RELEASE.jar</code>均为 1.4 M 左右；</p><p>从系统的资源使用上来说，Spring 运行期间只需要少量的操作系统资源（内存和 CPU）便能稳定运行。</p></li><li><p>面向容器</p><p>Spring 实现了对象的配置化生成和对象的生命周期管理，所以是面向容器的。</p></li><li><p>控制反转</p></li><li><p>面向切面</p></li><li><p>框架灵活</p></li></ul><h2 id="spring-的模块" tabindex="-1">Spring 的模块 <a class="header-anchor" href="#spring-的模块" aria-label="Permalink to &quot;Spring 的模块&quot;">​</a></h2><p>Spring 为企业应用程序提供一站式服务。Spring 模块提供的常用模块有核心容器层（Core Container）、数据访问层（Data Access）、Web 应用层（Web Access）。</p><h3 id="核心容器层" tabindex="-1">核心容器层 <a class="header-anchor" href="#核心容器层" aria-label="Permalink to &quot;核心容器层&quot;">​</a></h3><p>核心容器层包括 Spring-Beans、Spring-Core、Spring-Context 等模块。</p><ul><li><p>Spring-Beans</p><p>基于工厂模式实现对象的创建。Spring-Beans 通过 xml 配置文件实现了声明式的对象管理，将对象之间复杂的依赖关系从实际编码逻辑中解耦出来。</p></li><li><p>Spring-Core</p><p>Spring 的核心功能实现，提供 IoC 依赖注入功能的支持。</p></li><li><p>Spring-Context</p><p>在 Spring-Beans 和 Spring-Core 模块的基础上构建起来的。Spring-Context 模块继承自 Spring-Beans 模块，并且添加了国际化、事件传播、资源加载和透明地创建上下文等功能。</p></li></ul><h3 id="数据访问层" tabindex="-1">数据访问层 <a class="header-anchor" href="#数据访问层" aria-label="Permalink to &quot;数据访问层&quot;">​</a></h3><p>数据访问层包括：JDBC、ORM、OXM、JMS 和 TX 模块。</p><ul><li><p>JDBC (Java Data Base Connectivity)</p><p>提供了对数据库访问的抽象 JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java 程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。</p></li><li><p>ORM (Object Relational Mapping)</p><p>提供对 Hibernate 等 ORM 框架的支持。</p></li><li><p>OXM (Object XML Mapping)</p><p>提供对 Castor 等 OXM 框架的支持。</p></li><li><p>JMS (Java Message Service)</p><p>JMS 模块包括消息的生产和消费功能。从 Spring 4.1 开始，Spring 集成了 Spring-Messaging 模块，用于实现对消息队列的支持。</p></li><li><p>TX</p><p>提供对事务的支持。</p></li></ul><h3 id="web-应用层" tabindex="-1">Web 应用层 <a class="header-anchor" href="#web-应用层" aria-label="Permalink to &quot;Web 应用层&quot;">​</a></h3><p>Web 应用层主要包括 Web 交互和数据传输等相关功能，包括 Web、Web-MVC、Web-Socket 和 Web-Flux。</p><ul><li><p>Web</p><p>提供了面向 Web 应用的基本功能。</p></li><li><p>Web-MVC</p><p>提供对 Spring MVC 的实现。</p></li><li><p>Web-Socket</p><p>提供了对 WebSocket 的支持，WebSocket 可以让客户端和服务端进行双向通信。</p></li><li><p>Web-Flux</p><p>提供对 WebFlux 的支持。</p><p>目前最新的 5.x 版本中 Web 模块的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。</p></li></ul><h3 id="其他重要模块" tabindex="-1">其他重要模块 <a class="header-anchor" href="#其他重要模块" aria-label="Permalink to &quot;其他重要模块&quot;">​</a></h3><ul><li><p>Spring AOP</p><p>提供了面向切面的编程实现，允许应用程序通过定义方法拦截器和切入点来实现系统功能和业务功能之间的解耦。</p></li><li><p>Spring Aspects</p><p>提供了 Spring 与 AspectJ 的集成，是一个面向切面编程的模块。</p></li></ul><h2 id="spring-的注解" tabindex="-1">Spring 的注解 <a class="header-anchor" href="#spring-的注解" aria-label="Permalink to &quot;Spring 的注解&quot;">​</a></h2><h3 id="contoller" tabindex="-1">@Contoller <a class="header-anchor" href="#contoller" aria-label="Permalink to &quot;@Contoller&quot;">​</a></h3><p>SpringMVC 中，控制器 Controller 负责处理 DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个 Model，然后再把该 Model 返回给对应的 View 进行展示。</p><p>SpringMVC 提供了一个非常简便的定义 Controller 的方法，无需继承特定的类或者接口，只需使用 @Controller 标记一个类是 Contoller。</p><h3 id="requestmapping" tabindex="-1">@RequestMapping <a class="header-anchor" href="#requestmapping" aria-label="Permalink to &quot;@RequestMapping&quot;">​</a></h3><p>使用 @RequestMapping 来映射 URL 到 Controller，或者到 Controller 的处理方法上。method 的值一旦指定，则处理方法只对指定的 HTTP method 类型请求处理。</p><p>可以为多个方法映射相同的 URL 和不同的 HTTP method 类型，Spring MVC 根据请求的 method 类型是可以区分开这些方法的。</p><h3 id="requestparam-pathvariable" tabindex="-1">@RequestParam &amp; @PathVariable <a class="header-anchor" href="#requestparam-pathvariable" aria-label="Permalink to &quot;@RequestParam &amp; @PathVariable&quot;">​</a></h3><p>在 SpringMVC 中，两者的作用都是将 request 里的参数值绑定到 Controller 里的方法参数中，区别在于 URL 的写法不同。</p><ul><li>使用 @RequestParam 时，URL 是这样的：</li></ul><div class="language-html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">http://host:port/path?参数名=参数值</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ul><li>使用 @PathVariable 时，URL 是这样的：</li></ul><div class="language-html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">http://host:port/path/参数值</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="responsebody" tabindex="-1">@ResponseBody <a class="header-anchor" href="#responsebody" aria-label="Permalink to &quot;@ResponseBody&quot;">​</a></h3><p>该注解用于将 Controller 中方法返回的对象，通过适当的 HttpMessageConverter 转换为指定的格式后，写入到 Response 对象的 bodys 数据区。</p><h3 id="service-controller-repository-component" tabindex="-1">@Service &amp; @Controller &amp; @Repository &amp; @Component <a class="header-anchor" href="#service-controller-repository-component" aria-label="Permalink to &quot;@Service &amp; @Controller &amp; @Repository &amp; @Component&quot;">​</a></h3><p>@Service、 @Contrller、 @Repository 其实这 3 个注解和 @Component 是等效的，用在实现类上：</p><ul><li>@Service 用于标注业务层组件</li><li>@Controller 用于标注控制层组件</li><li>@Repository 用于编著数据访问组件</li><li>@Component 泛指组件，当组件不好归类时，可以使用这个注解进行标注</li></ul><h3 id="value" tabindex="-1">@Value <a class="header-anchor" href="#value" aria-label="Permalink to &quot;@Value&quot;">​</a></h3><p>在 Spring 3.0 中，可以通过使用 @Value，对一些如 xxx.properties 文件中的文件，进行键值对的注入。</p><h3 id="autowired" tabindex="-1">@Autowired <a class="header-anchor" href="#autowired" aria-label="Permalink to &quot;@Autowired&quot;">​</a></h3><p>@Autowired 可以对成员变量、成员方法和构造函数进行标注，来完成自动装配工作。</p><h3 id="autowired-resource" tabindex="-1">@Autowired &amp; @Resource <a class="header-anchor" href="#autowired-resource" aria-label="Permalink to &quot;@Autowired &amp; @Resource&quot;">​</a></h3><p>@Autowired 是 Spring 提供的注解，采用的策略是<strong>按照类型</strong>注入的：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> UserService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Autowired</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    userDao; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在 Spring 容器中找到类型为 UserDao 的对象，将其注入</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>存在问题：同一类型有多个 Bean，可以使用 @Qualifier 具体去装配哪个对象。</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> UserService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Autowired</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Qualifier</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;userDao&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    userDao; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在 Spring 容器中找到类型为 UserDao，名称为 userDao 的对象，将其注入</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>@Resource 是 J2EE 提供的注解，默认是<strong>按照名称</strong>注入的：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Service{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Resource</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    userDao; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 自动按名称进行装配</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Resource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;studentDao&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    studentDao; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 按名称进行装配，找不到会抛出异常</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Resource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;TeacherDao&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    teacherDao; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 按类型进行装配，找不到或者找到多个都会抛出异常</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Resource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;manDao&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;ManDao&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    manDao;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 找唯一匹配的 Bean 进行装配，如果找不到则会抛出异常</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div>`,46),l=[p];function r(t,h,o,k,d,c){return i(),a("div",null,l)}const b=s(n,[["render",r]]);export{g as __pageData,b as default};
