import{_ as a,c as t,o as e,a4 as i}from"./chunks/framework.DpC1ZpOZ.js";const b=JSON.parse('{"title":"锁机制","description":"","frontmatter":{},"headers":[],"relativePath":"java/MySQL/1_锁机制.md","filePath":"java/MySQL/1_锁机制.md","lastUpdated":null}'),l={name:"java/MySQL/1_锁机制.md"},s=i(`<h1 id="锁机制" tabindex="-1">锁机制 <a class="header-anchor" href="#锁机制" aria-label="Permalink to &quot;锁机制&quot;">​</a></h1><h2 id="数据库锁的分类" tabindex="-1">数据库锁的分类 <a class="header-anchor" href="#数据库锁的分类" aria-label="Permalink to &quot;数据库锁的分类&quot;">​</a></h2><p>按照锁的<strong>粒度</strong>划分：</p><ul><li>表级锁</li><li>行级锁</li><li>页级锁</li></ul><p>按照锁的<strong>级别</strong>划分：</p><ul><li>共享锁</li><li>排它锁</li></ul><p>按照<strong>使用方式</strong>划分：</p><ul><li>乐观锁</li><li>悲观锁</li></ul><h2 id="行级锁、表级锁、页级锁" tabindex="-1">行级锁、表级锁、页级锁 <a class="header-anchor" href="#行级锁、表级锁、页级锁" aria-label="Permalink to &quot;行级锁、表级锁、页级锁&quot;">​</a></h2><h3 id="_1-行级锁" tabindex="-1">1. 行级锁 <a class="header-anchor" href="#_1-行级锁" aria-label="Permalink to &quot;1. 行级锁&quot;">​</a></h3><p>行级锁是 MySQL 中锁定粒度最细的一种锁，表示只针对当前行进行加锁。行级锁分为共享锁和排他锁。</p><p>特点：</p><ul><li>开销大，加锁慢</li><li>会出现死锁</li><li>锁定粒度最小，发生锁冲突的概率最低，并发度最高</li></ul><h3 id="_2-表级锁" tabindex="-1">2. 表级锁 <a class="header-anchor" href="#_2-表级锁" aria-label="Permalink to &quot;2. 表级锁&quot;">​</a></h3><p>表级锁时 MySQL 中锁定粒度最大的一种锁，表示对当前操作的整张表进行加锁。最常用的 MyISAM 和 InnoDB 都支持表级锁。</p><p>特点：</p><ul><li>开销小，加锁快</li><li>不会出现死锁</li><li>锁定粒度最大，发生锁冲突的概率最高，并发度最低</li></ul><h3 id="_3-页级锁" tabindex="-1">3. 页级锁 <a class="header-anchor" href="#_3-页级锁" aria-label="Permalink to &quot;3. 页级锁&quot;">​</a></h3><p>页级锁是 MySQL 中锁定粒度介于表级锁和行级锁之间的一种锁。</p><p>特点：</p><ul><li>开销和加锁时间介于表级锁和行级锁之间</li><li>会出现死锁</li><li>锁定粒度介于表锁和行锁之间，并发度一般</li></ul><div align="center"><img src="https://github.com/DuHouAn/ImagePro/raw/master/java-notes/database/1a851e90-0d5c-4d4f-ac54-34c20ecfb903.jpg" width="350px"></div><h2 id="共享锁和排他锁" tabindex="-1">共享锁和排他锁 <a class="header-anchor" href="#共享锁和排他锁" aria-label="Permalink to &quot;共享锁和排他锁&quot;">​</a></h2><h3 id="_1-共享锁-s" tabindex="-1">1. 共享锁（S） <a class="header-anchor" href="#_1-共享锁-s" aria-label="Permalink to &quot;1. 共享锁（S）&quot;">​</a></h3><p>共享锁（Shared）又称读锁，是读取操作创建的锁。</p><p>如果事务 T 对数据 A 加上共享锁后，则其他事务只能对 A 再加共享锁，不能加排他锁。获准共享锁的事务只能读数据，不能修改数据。</p><h3 id="_2-排他锁-x" tabindex="-1">2. 排他锁（X） <a class="header-anchor" href="#_2-排他锁-x" aria-label="Permalink to &quot;2. 排他锁（X）&quot;">​</a></h3><p>排他锁（eXclusive）又称写锁。</p><p>如果事务 T 对数据 A 加上排他锁后，则其他事务不能再对 A 加上任何类型的锁。获取排他锁的事务既能读数据，又能修改数据。</p><p>共享锁和排他锁的兼容关系如下：</p><table tabindex="0"><thead><tr><th style="text-align:center;">-</th><th style="text-align:center;">X</th><th style="text-align:center;">S</th></tr></thead><tbody><tr><td style="text-align:center;">X</td><td style="text-align:center;">冲突</td><td style="text-align:center;">冲突</td></tr><tr><td style="text-align:center;">S</td><td style="text-align:center;">冲突</td><td style="text-align:center;">兼容</td></tr></tbody></table><h2 id="意向锁" tabindex="-1">意向锁 <a class="header-anchor" href="#意向锁" aria-label="Permalink to &quot;意向锁&quot;">​</a></h2><p>意向锁是<strong>表级锁</strong>，但表示事务正在读写某一行记录，而不是整个表。所以意向锁之间不会发生冲突，真正的冲突发生在加行锁时检查。</p><h3 id="_1-意向共享锁-is" tabindex="-1">1. 意向共享锁（IS） <a class="header-anchor" href="#_1-意向共享锁-is" aria-label="Permalink to &quot;1. 意向共享锁（IS）&quot;">​</a></h3><p>表示<strong>事务准备给数据行加共享锁</strong>，也就是说事务在一个数据行加共享锁前必须先获取该表的 IS 锁。</p><h3 id="_2-意向排他锁-ix" tabindex="-1">2. 意向排他锁（IX） <a class="header-anchor" href="#_2-意向排他锁-ix" aria-label="Permalink to &quot;2. 意向排他锁（IX）&quot;">​</a></h3><p>表示事务准备给数据行加排他锁，也就是说事务在一个数据行加排他锁前必须先获取该表的 IX 锁。</p><h2 id="悲观锁和乐观锁" tabindex="-1">悲观锁和乐观锁 <a class="header-anchor" href="#悲观锁和乐观锁" aria-label="Permalink to &quot;悲观锁和乐观锁&quot;">​</a></h2><h3 id="_1-悲观锁" tabindex="-1">1. 悲观锁 <a class="header-anchor" href="#_1-悲观锁" aria-label="Permalink to &quot;1. 悲观锁&quot;">​</a></h3><p>悲观锁机制认为每一步如果不采取同步措施都会出现问题，<strong>依赖于数据库的锁机制</strong>。关系型数据库里边就用到了很多悲观锁机制，比如<strong>行锁、表锁</strong>等，<strong>读锁、写锁</strong>等，都是在做操作之前先上锁。</p><p>如果锁定时间过长，用户长时间无法访问，会影响程序的并发访问。</p><h3 id="_2-乐观锁" tabindex="-1">2. 乐观锁 <a class="header-anchor" href="#_2-乐观锁" aria-label="Permalink to &quot;2. 乐观锁&quot;">​</a></h3><p>先执行，如果存在冲突，则采取一个补偿措施（比如告知用户失败）。一般有 2 种实现方式：</p><ul><li>使用版本号</li><li>使用时间戳</li></ul><h2 id="mysql-隐式与显式锁定" tabindex="-1">MySQL 隐式与显式锁定 <a class="header-anchor" href="#mysql-隐式与显式锁定" aria-label="Permalink to &quot;MySQL 隐式与显式锁定&quot;">​</a></h2><p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。</p><p>InnoDB 也可以使用特定的语句进行显示锁定：</p><div class="language-sql vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ... LOCK </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">In</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SHARE MODE;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ... </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FOR</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> UPDATE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div>`,48),n=[s];function r(h,o,d,p,c,u){return e(),t("div",null,n)}const k=a(l,[["render",r]]);export{b as __pageData,k as default};
