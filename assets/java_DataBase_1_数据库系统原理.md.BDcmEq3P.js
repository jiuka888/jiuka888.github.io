import{_ as t,c as e,o as a,a4 as r}from"./chunks/framework.DpC1ZpOZ.js";const x=JSON.parse('{"title":"数据库系统原理","description":"","frontmatter":{},"headers":[],"relativePath":"java/DataBase/1_数据库系统原理.md","filePath":"java/DataBase/1_数据库系统原理.md","lastUpdated":1728037326000}'),n={name:"java/DataBase/1_数据库系统原理.md"},i=r('<h1 id="数据库系统原理" tabindex="-1">数据库系统原理 <a class="header-anchor" href="#数据库系统原理" aria-label="Permalink to &quot;数据库系统原理&quot;">​</a></h1><h2 id="事务" tabindex="-1">事务 <a class="header-anchor" href="#事务" aria-label="Permalink to &quot;事务&quot;">​</a></h2><h3 id="概念" tabindex="-1">概念 <a class="header-anchor" href="#概念" aria-label="Permalink to &quot;概念&quot;">​</a></h3><p>事务是<strong>逻辑上的一组操作</strong>，要么都执行，要么都不执行。</p><h3 id="特性-acid" tabindex="-1">特性 ACID <a class="header-anchor" href="#特性-acid" aria-label="Permalink to &quot;特性 ACID&quot;">​</a></h3><h4 id="_1-原子性-atomicity" tabindex="-1">1. 原子性（Atomicity） <a class="header-anchor" href="#_1-原子性-atomicity" aria-label="Permalink to &quot;1. 原子性（Atomicity）&quot;">​</a></h4><p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</p><p>回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p><h4 id="_2-一致性-consistency" tabindex="-1">2. 一致性（Consistency） <a class="header-anchor" href="#_2-一致性-consistency" aria-label="Permalink to &quot;2. 一致性（Consistency）&quot;">​</a></h4><p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。</p><h4 id="_3-隔离性-isolation" tabindex="-1">3. 隔离性（Isolation） <a class="header-anchor" href="#_3-隔离性-isolation" aria-label="Permalink to &quot;3. 隔离性（Isolation）&quot;">​</a></h4><p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p><h4 id="_4-持久性-durability" tabindex="-1">4. 持久性（Durability） <a class="header-anchor" href="#_4-持久性-durability" aria-label="Permalink to &quot;4. 持久性（Durability）&quot;">​</a></h4><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p><p>可以通过数据库备份和恢复来实现，在系统发生崩溃时，使用备份的数据库进行数据恢复。</p><h2 id="并发一致性问题" tabindex="-1">并发一致性问题 <a class="header-anchor" href="#并发一致性问题" aria-label="Permalink to &quot;并发一致性问题&quot;">​</a></h2><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p><h3 id="丢失修改" tabindex="-1">丢失修改 <a class="header-anchor" href="#丢失修改" aria-label="Permalink to &quot;丢失修改&quot;">​</a></h3><p>T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。</p><div align="center"><img src="https://github.com/DuHouAn/ImagePro/raw/master/java-notes/database/88ff46b3-028a-4dbb-a572-1f062b8b96d3.png" width="350px"></div><h3 id="脏读" tabindex="-1">脏读 <a class="header-anchor" href="#脏读" aria-label="Permalink to &quot;脏读&quot;">​</a></h3><p>T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p><div align="center"><img src="https://github.com/DuHouAn/ImagePro/raw/master/java-notes/database/dd782132-d830-4c55-9884-cfac0a541b8e.png" width="350px"></div><h3 id="不可重复读" tabindex="-1">不可重复读 <a class="header-anchor" href="#不可重复读" aria-label="Permalink to &quot;不可重复读&quot;">​</a></h3><p>T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p><div align="center"><img src="https://github.com/DuHouAn/ImagePro/raw/master/java-notes/database/c8d18ca9-0b09-441a-9a0c-fb063630d708.png" width="350px"></div><h3 id="幻影读" tabindex="-1">幻影读 <a class="header-anchor" href="#幻影读" aria-label="Permalink to &quot;幻影读&quot;">​</a></h3><p>T1 读取某个<strong>范围</strong>的数据，T2 在这个<strong>范围</strong>内插入新的数据，T1 再次读取这个<strong>范围</strong>的数据，此时读取的结果和和第一次读取的结果不同。</p><div align="center"><img src="https://github.com/DuHouAn/ImagePro/raw/master/java-notes/database/72fe492e-f1cb-4cfc-92f8-412fb3ae6fec.png" width="350px"></div><h2 id="事务隔离级别" tabindex="-1">事务隔离级别 <a class="header-anchor" href="#事务隔离级别" aria-label="Permalink to &quot;事务隔离级别&quot;">​</a></h2><p>产生并发不一致性问题主要原因是破坏了事务的<strong>隔离性</strong>，解决方法是通过<strong>并发控制</strong>来保证隔离性。并发控制可以通过封锁（加锁）来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的<strong>隔离级别</strong>，让用户以一种更轻松的方式处理并发一致性问题。</p><h3 id="未提交读-read-uncommitted" tabindex="-1">未提交读（READ UNCOMMITTED） <a class="header-anchor" href="#未提交读-read-uncommitted" aria-label="Permalink to &quot;未提交读（READ UNCOMMITTED）&quot;">​</a></h3><p>事务中的修改，即使没有提交，对其它事务也是可见的。</p><h3 id="提交读-read-committed" tabindex="-1">提交读（READ COMMITTED） <a class="header-anchor" href="#提交读-read-committed" aria-label="Permalink to &quot;提交读（READ COMMITTED）&quot;">​</a></h3><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p><h3 id="可重复读-repeatable-read" tabindex="-1">可重复读（REPEATABLE READ） <a class="header-anchor" href="#可重复读-repeatable-read" aria-label="Permalink to &quot;可重复读（REPEATABLE READ）&quot;">​</a></h3><p>保证在同一个事务中多次读取同一数据的结果是一样的。</p><h3 id="可串行化-serializable" tabindex="-1">可串行化（SERIALIZABLE） <a class="header-anchor" href="#可串行化-serializable" aria-label="Permalink to &quot;可串行化（SERIALIZABLE）&quot;">​</a></h3><p>强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。</p><p>隔离级别能解决的并发一致性问题：</p><table tabindex="0"><thead><tr><th style="text-align:center;">并发访问问题</th><th style="text-align:center;">事务隔离级别</th></tr></thead><tbody><tr><td style="text-align:center;">丢失修改</td><td style="text-align:center;">MySQL 所有事务隔离级别在数据库层面上均可避免</td></tr><tr><td style="text-align:center;">脏读</td><td style="text-align:center;">READ-COMMITTED 事务隔离级别以上可避免</td></tr><tr><td style="text-align:center;">不可重复读</td><td style="text-align:center;">REPEATABLE-READ 事务隔离级别以上可避免</td></tr><tr><td style="text-align:center;">幻读</td><td style="text-align:center;">SERIALIZABLE 事务隔离级别以上可避免</td></tr></tbody></table><p>即：</p><table tabindex="0"><thead><tr><th style="text-align:center;">事务隔离级别 \\ 并发问题</th><th style="text-align:center;">丢失修改</th><th style="text-align:center;">脏读</th><th style="text-align:center;">不可重复读</th><th style="text-align:center;">幻读</th></tr></thead><tbody><tr><td style="text-align:center;">未提交读 （READ UNCOMMITTED）</td><td style="text-align:center;">避免</td><td style="text-align:center;">发生</td><td style="text-align:center;">发生</td><td style="text-align:center;">发生</td></tr><tr><td style="text-align:center;">提交读 （READ COMMITTED）</td><td style="text-align:center;">避免</td><td style="text-align:center;">避免</td><td style="text-align:center;">发生</td><td style="text-align:center;">发生</td></tr><tr><td style="text-align:center;">可重复读 （REPEATABLE READ）</td><td style="text-align:center;">避免</td><td style="text-align:center;">避免</td><td style="text-align:center;">避免</td><td style="text-align:center;">发生</td></tr><tr><td style="text-align:center;">可串行化 （SERIALIZABLE）</td><td style="text-align:center;">避免</td><td style="text-align:center;">避免</td><td style="text-align:center;">避免</td><td style="text-align:center;">避免</td></tr></tbody></table>',43),l=[i];function d(o,s,c,h,b,g){return a(),e("div",null,l)}const u=t(n,[["render",d]]);export{x as __pageData,u as default};
