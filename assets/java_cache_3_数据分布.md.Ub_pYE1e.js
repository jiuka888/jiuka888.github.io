import{_ as a,c as e,o as t,a4 as _}from"./chunks/framework.DpC1ZpOZ.js";const m=JSON.parse('{"title":"数据分布","description":"","frontmatter":{},"headers":[],"relativePath":"java/cache/3_数据分布.md","filePath":"java/cache/3_数据分布.md","lastUpdated":1728037326000}'),r={name:"java/cache/3_数据分布.md"},o=_('<h1 id="数据分布" tabindex="-1">数据分布 <a class="header-anchor" href="#数据分布" aria-label="Permalink to &quot;数据分布&quot;">​</a></h1><h2 id="哈希分布" tabindex="-1">哈希分布 <a class="header-anchor" href="#哈希分布" aria-label="Permalink to &quot;哈希分布&quot;">​</a></h2><p>哈希分布就是将数据计算哈希值之后，按照哈希值分配到不同的节点上。例如有 N 个节点，数据的主键为 key，则将该数据分配的节点序号为：hash(key)%N。</p><p>传统的哈希分布算法存在一个问题：当节点数量变化时，也就是 N 值变化，那么几乎所有的数据都需要重新分布，将导致大量的数据迁移。</p><h2 id="顺序分布" tabindex="-1">顺序分布 <a class="header-anchor" href="#顺序分布" aria-label="Permalink to &quot;顺序分布&quot;">​</a></h2><p>将数据划分为多个连续的部分，按数据的 ID 或者时间分布到不同节点上。例如 User 表的 ID 范围为 1 ~ 7000，使用顺序分布可以将其划分成多个子表，对应的主键范围为 1 ~ 1000，1001 ~ 2000，...，6001 ~ 7000。</p><p>顺序分布相比于哈希分布的主要优点如下：</p><ul><li>能保持数据原有的顺序；</li><li>并且能够准确控制每台服务器存储的数据量，从而使得存储空间的利用率最大。</li></ul>',8),c=[o];function s(i,l,n,h,d,p){return t(),e("div",null,c)}const f=a(r,[["render",s]]);export{m as __pageData,f as default};
