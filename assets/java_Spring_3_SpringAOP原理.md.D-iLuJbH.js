import{_ as t,c as i,o as a,a4 as e}from"./chunks/framework.DpC1ZpOZ.js";const A=JSON.parse('{"title":"Spring AOP 原理","description":"","frontmatter":{},"headers":[],"relativePath":"java/Spring/3_SpringAOP原理.md","filePath":"java/Spring/3_SpringAOP原理.md","lastUpdated":1728037326000}'),s={name:"java/Spring/3_SpringAOP原理.md"},n=e(`<h1 id="spring-aop-原理" tabindex="-1">Spring AOP 原理 <a class="header-anchor" href="#spring-aop-原理" aria-label="Permalink to &quot;Spring AOP 原理&quot;">​</a></h1><p>AOP 即面向切面编程（Aspect Oriented Programing），实际上是将一些通用的功能横向抽取出来：</p><ul><li>一方面，减少系统的重复代码</li><li>另一方面，降低模块间的耦合度，比较好维护和扩展</li></ul><p>Spring AOP 将应用分为核心关注点和横切关注点。业务处理流程为核心关注点，被业务所依赖的公共部分为横切关注点。横切关注点的特点是其行为经常发生在核心关注点多出，而多处操作基本相似，比如权限认证、日志、事务等。AOP 的核心思想是将核心关注点和横切关注点分离开来，以降低模块耦合度。</p><p>Spring AOP 的应用场景主要有：</p><ul><li>权限统一管理授权</li><li>缓存统一维护</li><li>数据懒加载</li><li>资源池统一申请和管理</li><li>统一事务管理</li></ul><h2 id="aop-相关术语" tabindex="-1">AOP 相关术语 <a class="header-anchor" href="#aop-相关术语" aria-label="Permalink to &quot;AOP 相关术语&quot;">​</a></h2><table tabindex="0"><thead><tr><th style="text-align:center;">术语</th><th>解释</th><th style="text-align:center;">描述</th></tr></thead><tbody><tr><td style="text-align:center;">Joinpoint</td><td>连接点</td><td style="text-align:center;">所谓连接点是指那些被拦截到的点。在 Spring 中,这些点指的是<strong>方法</strong>,因为 Spring 只支持<strong>方法类型的连接点</strong>。</td></tr><tr><td style="text-align:center;">Pointcut</td><td>切入点</td><td style="text-align:center;">所谓切入点是指我们要<strong>对哪些 Joinpoint 进行拦截</strong>的定义。</td></tr><tr><td style="text-align:center;">Advice</td><td>通知/增强</td><td style="text-align:center;">所谓通知是指拦截到 Joinpoint 之后要执行的具体操作。通知分为前置通知，后置通知，异常通知，最终通知，环绕通知(切面要完成的功能)</td></tr><tr><td style="text-align:center;">Introduction</td><td>引介</td><td style="text-align:center;">引介是一种<strong>特殊的通知</strong>。在不修改类代码的前提下，可以在运行期为类动态地添加一些方法或字段</td></tr><tr><td style="text-align:center;">Target</td><td>目标对象</td><td style="text-align:center;">代理的目标对象</td></tr><tr><td style="text-align:center;">Weaving</td><td>织入</td><td style="text-align:center;">是指把增强应用到目标对象来创建新的代理对象的过程。 有三种织入方式：Spring 采用<strong>动态代理织入</strong>，而 AspectJ 采用<strong>编译期织入</strong>和<strong>类装载期织入</strong></td></tr><tr><td style="text-align:center;">Proxy</td><td>代理</td><td style="text-align:center;">一个类被 AOP 织入增强后，就产生一个结果代理类</td></tr><tr><td style="text-align:center;">Aspect</td><td>切面</td><td style="text-align:center;">是切入点和通知（/引介）的结合</td></tr></tbody></table><p>例如在 IUserDao 接口中：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> IUserDao</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> delete</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> update</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> search</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ul><li>IUserDao 被增强的对象，就是 Target(目标对象)</li><li>add()、delete()、update() 和 search() 都是 JoinPoint(连接点)</li><li>这里要对 add() 和 update() JoinPoint 进行拦截，则 add() 和 update() 就是 Pointcut(切入点)</li><li>Advice 指的是要增强的代码，也就是代码的增强</li><li>Weaving：指的是把增强(Advice)应用到目标对象(Target)创建新的代理对象的过程</li><li>Aspect：是切入点和通知的结合，在 add 或 update 方法上应用增强</li></ul><h2 id="aop-底层原理" tabindex="-1">AOP 底层原理 <a class="header-anchor" href="#aop-底层原理" aria-label="Permalink to &quot;AOP 底层原理&quot;">​</a></h2><p>AOP 的底层原理是动态代理机制：</p><ul><li>类实现了接口，JDK 动态代理</li><li>类未实现任何接口，Cglib 动态代理</li></ul><h2 id="aop-的-5-种通知类型" tabindex="-1">AOP 的 5 种通知类型 <a class="header-anchor" href="#aop-的-5-种通知类型" aria-label="Permalink to &quot;AOP 的 5 种通知类型&quot;">​</a></h2><ul><li><p>前置通知</p><p>在连接点前面执行，前置通知不会影响连接点的执行，除非此处抛出异常。</p></li><li><p>后置通知</p><p>在连接点执行完成后执行，不管是正常执行完成，还是抛出异常，都会执行返回通知中的内容。</p></li><li><p>成功通知</p><p>在连接点正常执行完成后执行，如果连接点抛出异常，则不会执行。</p></li><li><p>异常通知</p><p>在连接点抛出异常后执行。</p></li><li><p>环绕通知</p><p>环绕通知围绕在连接点前后，比如一个方法调用的前后。这是最强大的通知类型，能在方法调用前后自定义一些操作。环绕通知还需要负责决定是继续处理连接点（调用ProceedingJoinPoint 的 proceed 方法）还是中断执行。</p></li></ul><p>五种通知的执行顺序为：前置通知、环绕通知、成功通知/异常通知、后置通知。</p><h2 id="spring-aop-aspectj-aop" tabindex="-1">Spring AOP &amp; AspectJ AOP <a class="header-anchor" href="#spring-aop-aspectj-aop" aria-label="Permalink to &quot;Spring AOP  &amp; AspectJ AOP&quot;">​</a></h2><ul><li><p>增强时机</p><p>Spring AOP 是运行时增强；AspectJ 是编译时增强</p></li><li><p>底层原理</p><p>Spring AOP 基于代理；AspectJ 基于字节码操作 (Bytecode Manipulation)</p></li><li><p>性能</p><p>AspectJ 相比于 Spring AOP 功能更加强大，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。Spring AOP 相对来说更简单，并且 Spring AOP 已集成了 AspectJ，如果切面较少，那么两者性能差异不大，当切面较多时，最好选择 AspectJ ，它比 Spring AOP 快很多。</p></li></ul>`,19),l=[n];function p(r,d,o,h,c,g){return a(),i("div",null,l)}const u=t(s,[["render",p]]);export{A as __pageData,u as default};
