import{_ as s,c as n,o as a,a4 as i}from"./chunks/framework.DpC1ZpOZ.js";const d=JSON.parse('{"title":"","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"java/JavaInterview/13_spring_69.md","filePath":"java/JavaInterview/13_spring_69.md","lastUpdated":1728901392000}'),p={name:"java/JavaInterview/13_spring_69.md"},l=i(`<p>Spring面试题 69道</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Spring 概述</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 什么是 spring</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Spring 是个 java 企业级应用的开源开发框架。Spring 主要用来开发 Java 应用，</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">但是有些扩展是针对构建 J2EE 平台的 web 应用。Spring 框架目标是简化 Java 企</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">业级应用开发，并通过 POJO 为基础的编程模型促进良好的编程习惯。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 使用 Spring 框架的好处是什么？</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">轻量：Spring 是轻量的，基本的版本大约 2MB</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">控制反转：Spring 通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">创建或查找依赖的对象们</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">面向切面的编程(AOP)：Spring 支持面向切面的编程，并且把应用业务逻辑和系统服</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">务分开</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">容器：Spring 包含并管理应用中对象的生命周期和配置</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MVC 框架：Spring 的 WEB 框架是个精心设计的框架，是 Web 框架的一个很好的</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">替代品</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">局事务（JTA）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">异 常 处 理 ： Spring 提 供 方 便 的 API 把 具 体 技 术 相 关 的 异 常 （ 比 如 由 JDBC ，</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Hibernate or JDO 抛出的）转化为一致的 unchecked 异常</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Spring 由哪些模块组成？</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">以下是 Spring 框架的基本模块：</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Core module</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Bean module</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Context module</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Expression Language module</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">JDBC module</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ORM module</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">OXM module</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Java Messaging </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Service</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(JMS) module</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Transaction module</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Web module</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Web</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Servlet module</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Web</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Struts module</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Web</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Portlet module</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 核心容器（应用上下文) 模块</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">这是基本的 Spring 模块，提供 spring 框架的基础功能，BeanFactory 是 任何以</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">spring 为基础的应用的核心。Spring 框架建立在此模块之上，它使 Spring 成为一</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">个容器。</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> BeanFactory – BeanFactory 实现举例</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Bean 工厂是工厂模式的一个实现，提供了控制反转功能，用来把应用的配置和依赖</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">从正真的应用代码中分离。最常用的 BeanFactory 实现是 XmlBeanFactory 类。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> XMLBeanFactory</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">最常用的就是 org.springframework.beans.factory.xml.XmlBeanFactory ，它根</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">据 XML 文件中的定义加载 beans。该容器从 XML 文件读取配置元数据并用它去创</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">建一个完全配置的系统或应用。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">7.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 解释 AOP 模块</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AOP 模块用于发给我们的 Spring 应用做面向切面的开发， 很多支持由 AOP 联盟提</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">供，这样就确保了 Spring 和其他 AOP 框架的共通性。这个模块将元数据编程引入</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Spring。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 解释 JDBC 抽象和 DAO 模块</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">通过使用 JDBC 抽象和 DAO 模块，保证数据库代码的简洁，并能避免数据库资源错</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">误关闭导致的问题，它在各种不同的数据库的错误信息之上，提供了一个统一的异常</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">访问层。它还利用 Spring 的 AOP 模块给 Spring 应用中的对象提供事务管理服务。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">9.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 解释对象</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">关系映射集成模块</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Spring 通过提供 ORM 模块，支持我们在直接 JDBC 之上使用一个对象</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">关系映射</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">映射(ORM)工具，Spring 支持集成主流的 ORM 框架，如 Hiberate,JDO 和 iBATIS</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">SQL Maps。Spring 的事务管理同样支持以上所有 ORM 框架及 JDBC。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 解释 WEB 模块</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Spring 的 WEB 模块是构建在 application context 模块基础之上，提供一个适合</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">web 应用的上下文。这个模块也包括支持多种面向 web 的任务，如透明地处理多个</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">文件上传请求和程序级请求参数的绑定到你的业务对象。它也有对 Jakarta Struts</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">的支持。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Spring 配置文件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Spring 配置文件是个 XML 文件，这个文件包含了类信息，描述了如何配置它们，</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">以及如何相互调用。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 什么是 Spring IOC 容器？</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">并且管理这些对象的整个生命周期。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">14.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> IOC 的优点是什么？</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">IOC 或 依赖注入把应用的代码量降到最低。它使应用容易测试，单元测试不再需要</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">单例和 JNDI 查找机制。最小的代价和最小的侵入性使松散耦合得以实现。IOC 容器</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">支持加载服务时的饿汉式初始化和懒加载。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">15.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ApplicationContext 通常的实现是什么？ FileSystemXmlApplicationContext ：此容器从一个 XML 文件中加载 beans</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ClassPathXmlApplicationContext：此容器也从一个 XML 文件中加载 beans</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">的定义，这里，你需要正确设置 classpath 因为这个容器将在 classpath 里找</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">bean 配置。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> WebXmlApplicationContext：此容器加载一个 XML 文件，此文件定义了一个</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">WEB 应用的所有 bean。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Bean 工厂和 Application contexts 有什么区别？</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Application contexts 提供一种方法处理文本消息，一个通常的做法是加载文件资源</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">（比如镜像），它们可以向注册为监听器的 bean 发布事件。另外，在容器或容器内</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">的 对 象 上 执 行 的 那 些 不 得 不 由 bean 工 厂 以 程 序 化 方 式 处 理 的 操 作 ， 可 以 在</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Application contexts 中 以 声 明 的 方 式 处 理 。 Application contexts 实 现 了</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MessageSource 接口，该接口的实现以可插拔的方式提供获取本地化消息的方法。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">17.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 一个 Spring 的应用看起来象什么？</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 一个定义了一些功能的接口</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 这实现包括属性，它的 Setter ， getter 方法和函数等</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Spring AOP</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Spring 的 XML 配置文件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 使用以上功能的客户端程序</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">依赖注入</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 什么是 Spring 的依赖注入？</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">依赖注入，是 IOC 的一个方面，是个通常的概念，它有多种解释。这概念是说你不</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">用创建对象，而只需要描述它如何被创建。你不在代码里直接组装你的组件和服务，</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">但是要在配置文件里描述哪些组件需要哪些服务，之后一个容器（IOC 容器）负责把</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">他们组装起来。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">19.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 有哪些不同类型的 IOC（依赖注入）方式？</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">构造器依赖注入：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">系列参数，每个参数代表一个对其他类的依赖。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Setter 方法注入：Setter 方法注入是容器通过调用无参构造器或无参 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">static</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 工厂 方</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">法实例化 bean 之后，调用该 bean 的 setter 方法，即实现了基于 setter 的依赖注</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">入。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 哪种依赖注入方式你建议使用，构造器注入，还是 Setter 方法注入？</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">你两种依赖方式都可以使用，构造器注入和 Setter 方法注入。最好的解决方案是用</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">构造器参数实现强制依赖，setter 方法实现可选依赖。Spring Beans</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">21.什么是 Spring beans？</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Spring beans 是那些形成 Spring 应用的主干的 java 对象。它们被 Spring IOC 容</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">器初始化，装配，和管理。这些 beans 通过容器中配置的元数据创建。比如，以 XML</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">文件中</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">bean</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 的形式定义。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Spring 框架定义的 beans 都是单件 beans。在 bean tag 中有个属性”singleton”，</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">如果它被赋为 TRUE，bean 就是单件，否则就是一个 prototype bean。默认是</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">TRUE，所以所有在 Spring 框架中的 beans 缺省都是单件。点击这里一图 Spring</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Bean 的生命周期。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">22.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 一个 Spring Bean 定义 包含什么？</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">一个 Spring Bean 的定义包含容器必知的所有配置元数据，包括如何创建一个</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">bean，它的生命周期详情及它的依赖。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">23.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 如何给 Spring 容器提供配置元数据？</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">这里有三种重要的方法给 Spring 容器提供配置元数据。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> XML 配置文件。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 基于注解的配置。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 基于 java 的配置。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">24.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 你怎样定义类的作用域？</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">当定义一个</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">bean</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 在 Spring 里，我们还能给这个 bean 声明一个作用域。它可以</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">通过 bean 定义中的 scope 属性来定义。如，当 Spring 要在需要的时候每次生产一</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">个新的 bean 实例，bean 的 scope 属性被指定为 prototype。另一方面，一个 bean</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">每 次 使 用 的 时 候 必 须 返 回 同 一 个 实 例 ， 这 个 bean 的 scope 属 性 必 须 设 为</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">singleton。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">25.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 解释 Spring 支持的几种 bean 的作用域</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Spring 框架支持以下五种 bean 的作用域：</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> singleton </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bean 在每个 Spring ioc 容器中只有一个实例。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prototype：一个 bean 的定义可以有多个实例。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> request：每次 http 请求都会创建一个 bean，该作用域仅在基于 web 的 Spring</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ApplicationContext 情形下有效。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> session：在一个 HTTP Session 中，一个 bean 定义对应一个实例。该作用域</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">仅在基于 web 的 Spring ApplicationContext 情形下有效。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> global</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">session：在一个全局的 HTTP Session 中，一个 bean 定义对应一个实</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">例。该作用域仅在基于 web 的 Spring ApplicationContext 情形下有效。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 缺省的 Spring bean 的作用域是 Singleton。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">26.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Spring 框架中的单例 bean 是线程安全的吗？</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">不，Spring 框架中的单例 bean 不是线程安全的。</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">27.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 解释 Spring 框架中 bean 的生命周期</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Spring 容器 从 XML 文件中读取 bean 的定义，并实例化 bean。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Spring 根据 bean 的定义填充所有的属性。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">如 果 bean 实 现 了 BeanNameAware 接 口 ， Spring 传 递 bean 的 ID 到</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">setBeanName 方法。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">如 果 Bean 实 现 了 BeanFactoryAware 接 口 ， Spring 传 递 beanfactory 给</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">setBeanFactory 方法。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">如 果 有 任 何 与 bean 相 关 联 的 BeanPostProcessors ， Spring 会 在</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">postProcesserBeforeInitialization</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()方法内调用它们。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">如果 bean 实现 IntializingBean 了，调用它的 afterPropertySet 方法，如果 bean</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">声明了初始化方法，调用此初始化方法。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">如 果 有 BeanPostProcessors 和 bean 关 联 ， 这 些 bean 的</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">postProcessAfterInitialization</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() 方法将被调用。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">如果 bean 实现了 DisposableBean，它将调用 </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">destroy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()方法。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">点击这里一图 Spring Bean 的生命周期。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">28.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 哪些是重要的 bean 生命周期方法？ 你能重载它们吗？</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">有两个重要的 bean 生命周期方法，第一个是 setup ， 它是在容器加载 bean 的时</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">候被调用。第二个方法是 teardown 它是在容器卸载类的时候被调用。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">The bean 标签有两个重要的属性（init</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">method 和 destroy</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">method）。用它们你</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">可 以 自 己 定 制 初 始 化 和 注 销 方 法 。 它 们 也 有 相 应 的 注 解 （ @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">PostConstruct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 和</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">PreDestroy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">）。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">29.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 什么是 Spring 的内部 bean？</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">当一个 bean 仅被用作另一个 bean 的属性时，它能被声明为一个内部 bean，为了</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">定义 inner bean，在 Spring 的 基于 XML 的 配置元数据中，可以在 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">property</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">或 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">constructor</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">arg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 元素内使用</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">bean</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 元素，内部 bean 通常是匿名的，它</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">们的 Scope 一般是 prototype。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 在 Spring 中如何注入一个 java 集合？</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Spring 提供以下几种集合的配置元素：</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">list</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">类型用于注入一列值，允许有相同的值。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">set</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 类型用于注入一组值，不允许有相同的值。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">map</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 类型用于注入一组键值对，键和值都可以为任意类型。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">props</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">类型用于注入一组键值对，键和值都只能为 String 类型。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">31.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 什么是 bean 装配？</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">装配，或 bean 装配是指在 Spring 容器中把 bean 组装到一起，前提是容器需要知</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">道 bean 的依赖关系，如何通过依赖注入来把它们装配到一起。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">32.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 什么是 bean 的自动装配？Spring 容 器 能 够 自 动 装 配 相 互 合 作 的 bean ， 这 意 味 着 容 器 不 需 要</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">constructor</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">arg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">和</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">property</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">配置，能通过 Bean 工厂自动处理 bean 之间的协</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">作。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">33.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 解释不同方式的自动装配</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">有五种自动装配的方式，可以用来指导 Spring 容器用自动装配方式来进行依赖注入</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">no：默认的方式是不进行自动装配，通过显式设置 ref 属性来进行装配。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">byName：通过参数名 自动装配，Spring 容器在配置文件中发现 bean 的 autowire</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">属性被设置成 byname，之后容器试图匹配、装配和该 bean 的属性具有相同名字的</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">bean。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">byType：通过参数类型自动装配，Spring 容器在配置文件中发现 bean 的 autowire</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">属性被设置成 byType，之后容器试图匹配、装配和该 bean 的属性具有相同类型的</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">bean。如果有多个 bean 符合条件，则抛出错误。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">constructor：这个方式类似于 byType， 但是要提供给构造器参数，如果没有确定</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">的带参数的构造器参数类型，将会抛出异常。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">autodetect：首先尝试使用 constructor 来自动装配，如果无法工作，则使用 byType</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">方式。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">34.自动装配有哪些局限性？</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">自动装配的局限性是：</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">重写：你仍需用 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">constructor</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">arg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">和 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">property</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 配置来定义依赖，意味着总要</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">重写自动装配。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">基本数据类型：你不能自动装配简单的属性，如基本数据类型，String 字符串，和类。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">模糊特性：自动装配不如显式装配精确，如果有可能，建议使用显式装配。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">35.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 你可以在 Spring 中注入一个 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 和一个空字符串吗？</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">可以。 Spring 注解</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">36.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 什么是基于 Java 的 Spring 注解配置</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 给一些注解的例子</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">基于 Java 的配置，允许你在少量的 Java 注解的帮助下，进行你的大部分 Spring</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">配置而非通过 XML 文件。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">以@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Configuration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 注解为例，它用来标记类可以当做一个 bean 的定义，被 Spring</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">IOC 容器使用。另一个例子是@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Bean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 注解，它表示此方法将要返回一个对象，作为</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">一个 bean 注册进 Spring 应用上下文。点击这里学习 JAVA 几大元注解。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">37.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 什么是基于注解的容器配置？</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">相对于 XML 文件，注解型的配置依赖于通过字节码元数据装配组件，而非尖括号的</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">声明。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">开发者通过在相应的类，方法或属性上使用注解的方式，直接组件类中进行配置，而</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">不是使用 xml 表述 bean 的装配关系。</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">38.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 怎样开启注解装配？</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">注解装配在默认情况下是不开启的，为了使用注解装配，我们必须在 Spring 配置文</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">件中配置 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">annotation</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">config</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">元素。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">39.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Required</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 注解</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">这个注解表明 bean 的属性必须在配置的时候设置，通过一个 bean 定义的显式的属</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">性 值 或 通 过 自 动 装 配 ， 若 @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Required</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 注 解 的 bean 属 性 未 被 设 置 ， 容 器 将 抛 出</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">BeanInitializationException。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">40.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Autowired</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 注解</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Autowired</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 注解提供了更细粒度的控制，包括在何处以及如何完成自动装配。它</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">的用法和@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Required</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 一样，修饰 setter 方法、构造器、属性或者具有任意名称和</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">或多个参数的 PN 方法。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">41.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Qualifier</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 注解</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">当 有 多 个 相同 类 型 的 bean 却 只 有 一 个需 要 自 动 装 配 时 ，将 @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Qualifier</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 注 解 和</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Autowire</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 注解结合使用以消除这种混淆，指定需要装配的确切的 bean。点击这</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">里学习更多常用注解。 Spring 数据访问</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">42.在 Spring 框架中如何更有效地使用 JDBC？</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">使用 SpringJDBC 框架，资源管理和错误处理的代价都会被减轻。所以开发者只需</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">写 statements 和 queries 从数据存取数据，JDBC 也可以在 Spring 框架提供的</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">模板类的帮助下更有效地被使用，这个模板叫 JdbcTemplate</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">43.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> JdbcTemplate</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">JdbcTemplate 类提供了很多便利的方法解决诸如把数据库数据转变成基本数据类</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">44.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Spring 对 DAO 的支持</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Spring 对数据访问对象（DAO）的支持旨在简化它和数据访问技术如 JDBC，</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Hibernate or JDO 结合使用。这使我们可以方便切换持久层。编码时也不用担心会</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">捕获每种技术特有的异常。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">45.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 使用 Spring 通过什么方式访问 Hibernate？</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">在 Spring 中有两种方式访问 Hibernate：</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">控制反转 Hibernate Template 和 Callback</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">继承 HibernateDAOSupport 提供一个 AOP 拦截器</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">46.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Spring 支持的 ORM</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Spring 支持以下 ORM：Hibernate</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">iBatis</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">JPA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (Java Persistence API)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">TopLink</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">JDO</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (Java Data Objects)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">OJB</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">47.如何通过 HibernateDaoSupport 将 Spring 和 Hibernate 结合起来？</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">用 Spring 的 SessionFactory 调用 LocalSessionFactory。集成过程分三步：</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">配置 the Hibernate SessionFactory</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">继承 HibernateDaoSupport 实现一个 DAO</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">在 AOP 支持的事务中装配</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">48.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Spring 支持的事务管理类型</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Spring 支持两种类型的事务管理：</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">编程式事务管理：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">难维护。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">声明式事务管理：这意味着你可以将业务代码和事务管理分离，你只需用注解和 XML</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">配置来管理事务。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">49.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Spring 框架的事务管理有哪些优点？</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">它为不同的事务 API 如 JTA，JDBC，Hibernate，JPA 和 JDO，提供一个不变</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">的编程模式。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">它为编程式事务管理提供了一套简单的 API 而不是一些复杂的事务 API 如</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">它支持声明式事务管理。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">它和 Spring 各种数据访问抽象层很好得集成。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">50.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 你更倾向用那种事务管理类型？</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">大多数 Spring 框架的用户选择声明式事务管理，因为它对应用代码的影响最小，因</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">此更符合一个无侵入的轻量级容器的思想。声明式事务管理要优于编程式事务管理，</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">虽然比编程式事务管理（这种方式允许你通过代码控制事务）少了一点灵活性。 Spring 面向切面编程（AOP）</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">51.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 解释 AOP</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">面向切面的编程，或 AOP， 是一种编程技术，允许程序模块化横向切割关注点，或</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">横切典型的责任划分，如日志和事务管理。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">52.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Aspect 切面</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AOP 核心就是切面，它将多个类的通用行为封装成可重用的模块，该模块含有一组</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">API 提供横切功能。比如，一个日志模块可以被称作日志的 AOP 切面。根据需求的</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">不同，一个应用程序可以有若干切面。在 Spring AOP 中，切面通过带有@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Aspect</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">注解的类实现。</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">52.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 在 Spring AOP 中，关注点和横切关注的区别是什么？</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">关注点是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">功能。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">横切关注点是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">切关注点。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">54.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 连接点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">连接点代表一个应用程序的某个位置，在这个位置我们可以插入一个 AOP 切面，它</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">实际上是个应用程序执行 Spring AOP 的位置。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">55.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 通知</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">通 知 是 个 在 方 法 执 行 前 或 执 行 后 要 做 的 动 作 ， 实 际 上 是 程 序 执 行 时 要 通 过</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">SpringAOP 框架触发的代码段。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Spring 切面可以应用五种类型的通知：</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">before：前置通知，在一个方法执行前被调用</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">after：在方法执行之后调用的通知，无论方法执行是否成功</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">after</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">returning：仅当方法成功完成后执行的通知</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">after</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">throwing：在方法抛出异常退出时执行的通知</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">around：在方法执行之前和之后调用的通知</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">56.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 切点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">切入点是一个或一组连接点，通知将在这些位置执行。可以通过表达式或匹配的方式</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">指明切入点。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">57.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 什么是引入？</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">引入允许我们在已存在的类中增加新的方法和属性。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">58.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 什么是目标对象？</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">被一个或者多个切面所通知的对象。它通常是一个代理对象。也指被通知（advised）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">对象。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">59.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 什么是代理？</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">代理是通知目标对象后创建的对象。从客户端的角度看，代理对象和目标对象是一样</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">的。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">60.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 有几种不同类型的自动代理？</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">BeanNameAutoProxyCreator</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">DefaultAdvisorAutoProxyCreator</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Metadata autoproxying</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">61.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 什么是织入。什么是织入应用的不同点？</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">织入是将切面和到其他应用类型或对象连接或创建一个被通知对象的过程。织入可以在编译时，加载时，或运行时完成。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">62.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 解释基于 XML Schema 方式的切面实现</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">在这种情况下，切面由常规类以及基于 XML 的配置实现。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">63.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 解释基于注解的切面实现</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">在这种情况下(基于@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">AspectJ</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 的实现)，涉及到的切面声明的风格与带有 java5 标注</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">的普通 java 类一致。 Spring 的 MVC</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">64.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 什么是 Spring 的 MVC 框架？</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Spring 配备构建 Web 应用的全功能 MVC 框架。Spring 可以很便捷地和其他 MVC</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">框架集成，如 Struts，Spring 的 MVC 框架用控制反转把业务对象和控制逻辑清晰</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">地隔离。它也允许以声明的方式把请求参数和业务对象绑定。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">65.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> DispatcherServlet</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Spring 的 MVC 框架是围绕 DispatcherServlet 来设计的，它用来处理所有的 HTTP</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">请求和响应。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">66.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> WebApplicationContext</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">WebApplicationContext 继承了 ApplicationContext 并增加了一些 WEB 应用</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">必备的特有功能，它不同于一般的 ApplicationContext ，因为它能处理主题，并找</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">到被关联的 servlet。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">67.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 什么是 Spring MVC 框架的控制器？</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">控制器提供一个访问应用程序的行为，此行为通常通过服务接口实现。控制器解析用</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">户输入并将其转换为一个由视图呈现给用户的模型。Spring 用一个非常抽象的方式</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">实现了一个控制层，允许用户创建多种用途的控制器。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">68.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Controller</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 注解</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">该注解表明该类扮演控制器的角色，Spring 不需要你继承任何其他控制器基类或引</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">用 Servlet API。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">69.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RequestMapping</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 注解</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">该注解是用来映射一个 URL 到一个类或一个特定的方处理法上。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br><span class="line-number">94</span><br><span class="line-number">95</span><br><span class="line-number">96</span><br><span class="line-number">97</span><br><span class="line-number">98</span><br><span class="line-number">99</span><br><span class="line-number">100</span><br><span class="line-number">101</span><br><span class="line-number">102</span><br><span class="line-number">103</span><br><span class="line-number">104</span><br><span class="line-number">105</span><br><span class="line-number">106</span><br><span class="line-number">107</span><br><span class="line-number">108</span><br><span class="line-number">109</span><br><span class="line-number">110</span><br><span class="line-number">111</span><br><span class="line-number">112</span><br><span class="line-number">113</span><br><span class="line-number">114</span><br><span class="line-number">115</span><br><span class="line-number">116</span><br><span class="line-number">117</span><br><span class="line-number">118</span><br><span class="line-number">119</span><br><span class="line-number">120</span><br><span class="line-number">121</span><br><span class="line-number">122</span><br><span class="line-number">123</span><br><span class="line-number">124</span><br><span class="line-number">125</span><br><span class="line-number">126</span><br><span class="line-number">127</span><br><span class="line-number">128</span><br><span class="line-number">129</span><br><span class="line-number">130</span><br><span class="line-number">131</span><br><span class="line-number">132</span><br><span class="line-number">133</span><br><span class="line-number">134</span><br><span class="line-number">135</span><br><span class="line-number">136</span><br><span class="line-number">137</span><br><span class="line-number">138</span><br><span class="line-number">139</span><br><span class="line-number">140</span><br><span class="line-number">141</span><br><span class="line-number">142</span><br><span class="line-number">143</span><br><span class="line-number">144</span><br><span class="line-number">145</span><br><span class="line-number">146</span><br><span class="line-number">147</span><br><span class="line-number">148</span><br><span class="line-number">149</span><br><span class="line-number">150</span><br><span class="line-number">151</span><br><span class="line-number">152</span><br><span class="line-number">153</span><br><span class="line-number">154</span><br><span class="line-number">155</span><br><span class="line-number">156</span><br><span class="line-number">157</span><br><span class="line-number">158</span><br><span class="line-number">159</span><br><span class="line-number">160</span><br><span class="line-number">161</span><br><span class="line-number">162</span><br><span class="line-number">163</span><br><span class="line-number">164</span><br><span class="line-number">165</span><br><span class="line-number">166</span><br><span class="line-number">167</span><br><span class="line-number">168</span><br><span class="line-number">169</span><br><span class="line-number">170</span><br><span class="line-number">171</span><br><span class="line-number">172</span><br><span class="line-number">173</span><br><span class="line-number">174</span><br><span class="line-number">175</span><br><span class="line-number">176</span><br><span class="line-number">177</span><br><span class="line-number">178</span><br><span class="line-number">179</span><br><span class="line-number">180</span><br><span class="line-number">181</span><br><span class="line-number">182</span><br><span class="line-number">183</span><br><span class="line-number">184</span><br><span class="line-number">185</span><br><span class="line-number">186</span><br><span class="line-number">187</span><br><span class="line-number">188</span><br><span class="line-number">189</span><br><span class="line-number">190</span><br><span class="line-number">191</span><br><span class="line-number">192</span><br><span class="line-number">193</span><br><span class="line-number">194</span><br><span class="line-number">195</span><br><span class="line-number">196</span><br><span class="line-number">197</span><br><span class="line-number">198</span><br><span class="line-number">199</span><br><span class="line-number">200</span><br><span class="line-number">201</span><br><span class="line-number">202</span><br><span class="line-number">203</span><br><span class="line-number">204</span><br><span class="line-number">205</span><br><span class="line-number">206</span><br><span class="line-number">207</span><br><span class="line-number">208</span><br><span class="line-number">209</span><br><span class="line-number">210</span><br><span class="line-number">211</span><br><span class="line-number">212</span><br><span class="line-number">213</span><br><span class="line-number">214</span><br><span class="line-number">215</span><br><span class="line-number">216</span><br><span class="line-number">217</span><br><span class="line-number">218</span><br><span class="line-number">219</span><br><span class="line-number">220</span><br><span class="line-number">221</span><br><span class="line-number">222</span><br><span class="line-number">223</span><br><span class="line-number">224</span><br><span class="line-number">225</span><br><span class="line-number">226</span><br><span class="line-number">227</span><br><span class="line-number">228</span><br><span class="line-number">229</span><br><span class="line-number">230</span><br><span class="line-number">231</span><br><span class="line-number">232</span><br><span class="line-number">233</span><br><span class="line-number">234</span><br><span class="line-number">235</span><br><span class="line-number">236</span><br><span class="line-number">237</span><br><span class="line-number">238</span><br><span class="line-number">239</span><br><span class="line-number">240</span><br><span class="line-number">241</span><br><span class="line-number">242</span><br><span class="line-number">243</span><br><span class="line-number">244</span><br><span class="line-number">245</span><br><span class="line-number">246</span><br><span class="line-number">247</span><br><span class="line-number">248</span><br><span class="line-number">249</span><br><span class="line-number">250</span><br><span class="line-number">251</span><br><span class="line-number">252</span><br><span class="line-number">253</span><br><span class="line-number">254</span><br><span class="line-number">255</span><br><span class="line-number">256</span><br><span class="line-number">257</span><br><span class="line-number">258</span><br><span class="line-number">259</span><br><span class="line-number">260</span><br><span class="line-number">261</span><br><span class="line-number">262</span><br><span class="line-number">263</span><br><span class="line-number">264</span><br><span class="line-number">265</span><br><span class="line-number">266</span><br><span class="line-number">267</span><br><span class="line-number">268</span><br><span class="line-number">269</span><br><span class="line-number">270</span><br><span class="line-number">271</span><br><span class="line-number">272</span><br><span class="line-number">273</span><br><span class="line-number">274</span><br><span class="line-number">275</span><br><span class="line-number">276</span><br><span class="line-number">277</span><br><span class="line-number">278</span><br><span class="line-number">279</span><br><span class="line-number">280</span><br><span class="line-number">281</span><br><span class="line-number">282</span><br><span class="line-number">283</span><br><span class="line-number">284</span><br><span class="line-number">285</span><br><span class="line-number">286</span><br><span class="line-number">287</span><br><span class="line-number">288</span><br><span class="line-number">289</span><br><span class="line-number">290</span><br><span class="line-number">291</span><br><span class="line-number">292</span><br><span class="line-number">293</span><br><span class="line-number">294</span><br><span class="line-number">295</span><br><span class="line-number">296</span><br><span class="line-number">297</span><br><span class="line-number">298</span><br><span class="line-number">299</span><br><span class="line-number">300</span><br><span class="line-number">301</span><br><span class="line-number">302</span><br><span class="line-number">303</span><br><span class="line-number">304</span><br><span class="line-number">305</span><br><span class="line-number">306</span><br><span class="line-number">307</span><br><span class="line-number">308</span><br><span class="line-number">309</span><br><span class="line-number">310</span><br><span class="line-number">311</span><br><span class="line-number">312</span><br><span class="line-number">313</span><br><span class="line-number">314</span><br><span class="line-number">315</span><br><span class="line-number">316</span><br><span class="line-number">317</span><br><span class="line-number">318</span><br><span class="line-number">319</span><br><span class="line-number">320</span><br><span class="line-number">321</span><br><span class="line-number">322</span><br><span class="line-number">323</span><br><span class="line-number">324</span><br><span class="line-number">325</span><br><span class="line-number">326</span><br><span class="line-number">327</span><br><span class="line-number">328</span><br><span class="line-number">329</span><br><span class="line-number">330</span><br><span class="line-number">331</span><br><span class="line-number">332</span><br></div></div>`,2),e=[l];function h(k,E,r,t,b,c){return a(),n("div",null,e)}const y=s(p,[["render",h]]);export{d as __pageData,y as default};
