import{_ as a,c as o,o as t,a4 as r}from"./chunks/framework.DpC1ZpOZ.js";const d=JSON.parse('{"title":"Java I/O 方式","description":"","frontmatter":{},"headers":[],"relativePath":"java/JavaIO/8_JavaIO方式.md","filePath":"java/JavaIO/8_JavaIO方式.md","lastUpdated":null}'),e={name:"java/JavaIO/8_JavaIO方式.md"},n=r('<h1 id="java-i-o-方式" tabindex="-1">Java I/O 方式 <a class="header-anchor" href="#java-i-o-方式" aria-label="Permalink to &quot;Java I/O 方式&quot;">​</a></h1><h2 id="bio-nio-aio" tabindex="-1">BIO &amp; NIO &amp; AIO <a class="header-anchor" href="#bio-nio-aio" aria-label="Permalink to &quot;BIO &amp; NIO &amp; AIO&quot;">​</a></h2><p>Java IO 的方式通常分为阻塞的 BIO（Blocking IO）、同步非阻塞的 NIO（New IO） 和异步非阻塞的 AIO（Asynchronous IO）。</p><p>JDK1.4 之前只支持 BIO，JDK1.4 以后开始支持 NIO，JDK1.7 开始支持 AIO。</p><h3 id="_1-bio" tabindex="-1">1. BIO <a class="header-anchor" href="#_1-bio" aria-label="Permalink to &quot;1. BIO&quot;">​</a></h3><p>BIO 是同步阻塞的。服务器的模式为<strong>一个连接一个线程</strong>。</p><p>客户端有连接请求时，就需要启动一个线程进行处理。如果这个连接不做任何事情，就会造成不必要的开销，可以通过<a href="https://duhouan.github.io/Java/#/Java_Concurrency/8_%E7%BA%BF%E7%A8%8B%E6%B1%A0" target="_blank" rel="noreferrer">线程池机制</a>改善。</p><h3 id="_2-nio" tabindex="-1">2. NIO <a class="header-anchor" href="#_2-nio" aria-label="Permalink to &quot;2. NIO&quot;">​</a></h3><p>NIO 是同步非阻塞的。服务器模式为<strong>一个请求一个线程</strong>。</p><p>NIO 最重要的地方是当一个连接建立后，不需要对应一个线程，这个连接会被注册到多路复用器上面，所以所有的连接只需要一个线程即可，当这个线程中的多路复用器进行轮询时，发现连接上有请求的话，才开启一个线程进行处理。</p><h3 id="_3-aio" tabindex="-1">3. AIO <a class="header-anchor" href="#_3-aio" aria-label="Permalink to &quot;3. AIO&quot;">​</a></h3><p>AIO 是异步阻塞的。服务器模式为<strong>一个有效请求一个线程</strong>。</p><p>客户端的 IO 请求都是由操作系统完成，再通知服务器去启动线程进行处理。真正的 IO 读写已经由内核完成了。</p><h2 id="bio-和-nio-的区别" tabindex="-1">BIO 和 NIO 的区别 <a class="header-anchor" href="#bio-和-nio-的区别" aria-label="Permalink to &quot;BIO 和 NIO 的区别&quot;">​</a></h2><ul><li><p><strong>是否阻塞</strong></p><p>BIO 是阻塞的，NIO 是非阻塞的。</p><p>BIO 中一个线程调用 read() / write() 时，该线程被阻塞；</p><p>NIO 中一个线程从 Channel 中读取数据到 Buffer 中，可以继续做别的操作，当数据读取到 Buffer 中后，线程再继续处理数据；一个线程请求写入数据到某个 Channel，但不需要等待完全写入，该线程可进行别的操作。</p></li><li><p><strong>缓冲区（Buffer）</strong></p><p>BIO 是面向流的，NIO 是面向缓冲区。</p><p>发送给一个通道的所有数据都必须首先放到缓冲区中，同样地，从通道中读取的任何数据都要先读到缓冲区中。也就是说，<strong>不会直接对通道进行读写数据，而是要先经过缓冲区</strong>。</p></li><li><p><strong>通道（Channel）</strong></p><p>NIO 通过 Chammel 进行读写。</p><p>通道和流的不同之处在于：流只能在一个方向上移动（一个流必须是 InputStream 或者 OutputStream 的子类），而<strong>通道是双向的</strong>，可以用于读、写或者同事用于读写。</p><p>通道只能和缓冲区交互，因为有缓冲区，通道可以异步读写。</p></li><li><p><strong>选择器（Selector）</strong></p><p>NIO 中一个线程使用一个选择器 Selector，通过<strong>轮询</strong>的方式去监听多个 Channel 上的事件。从而让一个线程就可以处理多个事件。</p><p>使用 Selector 的好处：使用更少的线程就可以来处理通道了，相比使用多个线程，<strong>减少了线程上下文切换带来的开销</strong>。</p></li></ul><h2 id="应用场景" tabindex="-1">应用场景 <a class="header-anchor" href="#应用场景" aria-label="Permalink to &quot;应用场景&quot;">​</a></h2><ul><li>BIO 适用于<strong>连接数目少且固定的架构</strong>。这种方式对服务器要求比较高，并发局限于应用中，程序直观简单，容易理解。</li><li>NIO 适用于<strong>连接数目多且连接比较短的架构</strong>。这种方式并发局限于应用中，但编程较复杂。</li><li>AIO 适用于<strong>连接数目多且连接比较长的架构</strong>。这种方式充分调用服务器的并发操作，但是编程复杂。</li></ul>',17),i=[n];function l(s,p,I,O,h,_){return t(),o("div",null,i)}const u=a(e,[["render",l]]);export{d as __pageData,u as default};
