import{_ as a,c as e,o as r,a4 as t}from"./chunks/framework.DpC1ZpOZ.js";const P=JSON.parse('{"title":"分布式系统设计理念","description":"","frontmatter":{},"headers":[],"relativePath":"java/distribution/1_分布式系统设计理念.md","filePath":"java/distribution/1_分布式系统设计理念.md","lastUpdated":1728037326000}'),o={name:"java/distribution/1_分布式系统设计理念.md"},i=t('<h1 id="分布式系统设计理念" tabindex="-1">分布式系统设计理念 <a class="header-anchor" href="#分布式系统设计理念" aria-label="Permalink to &quot;分布式系统设计理念&quot;">​</a></h1><h2 id="目标" tabindex="-1">目标 <a class="header-anchor" href="#目标" aria-label="Permalink to &quot;目标&quot;">​</a></h2><p>分布式架构的应用十分广泛：</p><ul><li>分布式文件系统：比如 Hadoop 的HDFS ，Google 的 GFS，淘宝的 TFS 等。</li><li>分布式缓存系统：Memcache，Hbase 等。</li><li>分布式数据库：MySQL ，Mariadb，PostgreSQL 等。</li></ul><p>分布式系统的目标是提升系统的<strong>整体性能</strong>和<strong>吞吐量</strong>另外还要尽量保证分布式系统的<strong>容错性</strong>。</p><h2 id="设计思路" tabindex="-1">设计思路 <a class="header-anchor" href="#设计思路" aria-label="Permalink to &quot;设计思路&quot;">​</a></h2><p>分布式系统 2 大设计思路：</p><ul><li>中心化</li><li>去中心化</li></ul><h3 id="中心化" tabindex="-1">中心化 <a class="header-anchor" href="#中心化" aria-label="Permalink to &quot;中心化&quot;">​</a></h3><ul><li><p><strong>2 种角色</strong></p><p>分布式集群中的节点机器按照角色分工，大体上分为两种角色：“领导”和“员工”。</p></li><li><p><strong>角色职责</strong></p><p>“领导”通常负责分发任务并监督“员工”，发现谁太闲了，就想发设法地给其安排新任务，确保没有一个“干活的”能够偷懒，如果“领导”发现某个“干活的”因为劳累过度而病倒了，则是不会考虑先尝试“医治”他的，而是一脚踢出去，然后把他的任务分给其他人。</p></li><li><p><strong>面临的问题</strong></p><p>最大问题是“领导”的安危问题，如果“领导”出了问题，则群龙无首。</p></li></ul><h3 id="去中心化" tabindex="-1">去中心化 <a class="header-anchor" href="#去中心化" aria-label="Permalink to &quot;去中心化&quot;">​</a></h3><ul><li><p><strong>地位平等</strong></p></li><li><p><strong>“去中心化”不是不要中心，而是由节点来自由选择中心</strong></p><p>集群的成员会自发的举行“会议”选举新的“领导”主持工作。</p></li><li><p><strong>面临的问题</strong></p><p>脑裂问题。脑裂指一个集群由于网络的故障，被分为至少两个彼此无法通信的单独集群，此时如果两个集群都各自工作，则可能会产生严重的数据冲突和错误。</p><p>一般的设计思路是，当集群判断发生了脑裂问题时，规模较小的集群就“自杀”或者拒绝服务。</p></li></ul><h2 id="基本概念" tabindex="-1">基本概念 <a class="header-anchor" href="#基本概念" aria-label="Permalink to &quot;基本概念&quot;">​</a></h2><h3 id="分布式与集群" tabindex="-1">分布式与集群 <a class="header-anchor" href="#分布式与集群" aria-label="Permalink to &quot;分布式与集群&quot;">​</a></h3><p><strong>分布式指的是一个业务拆分为多个子业务，部署在不同服务器上</strong>。比如一个电商系统，用户模块部署在 server1, 订单模块部署在 server2，促销模块部署在 server3，商品模块部署在 server4，他们之间通过远程 RPC 实现服务调用，这就叫分布式。强调的是不同功能模块，单独部署在不同的 server上，所有 server 加起来是一个完整的系统。</p><p><strong>集群指的是同一业务，部署在多个服务器上，更多强调的是灾备</strong>。比如一个电商系统，完整的部署在 server1 上一个，同样完整的部署在 server2 上，当 server1宕机，server2 仍然可以正常提供请求服务，这叫集群。同样对于某一功能模块，比如用户模块部署在 server1 上，同样部署在 server2 上，也叫做集群。分布式系统的每个功能模块节点，都可以用多机做成集群。</p><p>拿做菜示例，假如一个厨师做菜要经历切菜，炒菜两个功能，饭店为了提高速度招了两个厨师，每个厨师的工作一样，都是切菜，炒菜，这是集群。还有另一种方法提高效率，饭店招了一个切菜师傅，配合厨师，厨师不管切菜，只管炒菜了，和切菜师傅共同配合把菜做好，这叫分布式。</p><h3 id="nginx" tabindex="-1">Nginx <a class="header-anchor" href="#nginx" aria-label="Permalink to &quot;Nginx&quot;">​</a></h3><p>Nginx 作用是反向代理和负载均衡。</p><p>反向代理是指请求真实是到 server1 中，但是系统中为了统一或者做比如单点登录，会在 server2 服务器上安装一个 nginx，里面配置到 server1 的反向代理，那么之后请求 url 就可以写 server2 的地址，发出后到 server2, server2 会转发到 server1 上，类似一种代理的模式。</p><p>负载均衡是指如果一个系统的请求很多，我们可以把请求转发到不同的服务器上，用来分流。就类似于接了一个水管放水，水流量很大时候，水压大很可能会让一个水管爆炸，这时候接三个水管，就没问题了（这三个水管就是一个集群）。类似的在 nginx 服务器中配了 3 个 Tomcat 服务器，每个 Tomcat 服务器上都部署了整个系统，那么当请求数大的时候，可以分发到不同的 Tomcat。（其实这里每个 Tomcat 上部署同一个功能模块也叫集群）。</p><h3 id="rpc" tabindex="-1">RPC <a class="header-anchor" href="#rpc" aria-label="Permalink to &quot;RPC&quot;">​</a></h3><p>RPC (Remote Procedure Call) 即远程过程调用，对于分布式系统来讲，Tomcat1 上部署了用户模块，Tomcat2 上部署了订单模块，当用户下单时，请求到 Tomcat2，这时候可能要判断这个用户是否是 vip，或者是否有优惠券，这些方法是在 Tomcat1 用户模块上的，那么 Tomcat2 调用 Tomcat1 的服务获取这些信息，就叫 RPC 调用。</p><p>RPC 调用底层涉及到对象的序列化，反序列化，HTTP/TCP 传输，网络异步传输 Netty。</p><h3 id="分布式-java-应用" tabindex="-1">分布式 Java 应用 <a class="header-anchor" href="#分布式-java-应用" aria-label="Permalink to &quot;分布式 Java 应用&quot;">​</a></h3><p>网络通信：</p><ul><li><p>协议</p><p>TCP/IP</p><p>UDP/IP</p></li><li><p>IO</p><p>BIO</p><p>NIO-Reactor</p><p>AIO-Proactor</p></li></ul><p>基于消息方式的系统间通信：</p><ul><li><p>socket 方式</p><p>基于 Java 包：TCP/IP、UDP/IP</p><p>基于框架：Netty、Dubbo</p></li><li><p>消息方式</p><p>基于 Java 包：JMS</p><p>基于框架：RabbitMQ、RocketMQ</p></li></ul><p>基于远程调用方式的系统间通信：</p><ul><li><p>基于 Java 包</p><p>WebService</p></li><li><p>基于框架</p><p>Spring RMI、CXF</p></li></ul><h3 id="消息中间件-mq" tabindex="-1">消息中间件（MQ） <a class="header-anchor" href="#消息中间件-mq" aria-label="Permalink to &quot;消息中间件（MQ）&quot;">​</a></h3><p>MQ 消息中间件在分布式系统中的作用有很多，但是经常用到的还是<strong>异步解耦</strong>。</p><p>比如天猫下单流程，当用户支付后，后台接口执行的操作可能包括：1 验签，2 支付密码校验，3 扣库存，4 用户积分增加等等操作，其实我们希望的是2操作执行成功后立即给用户结果提示，而不是等到后续各个操作完成后才去提示，因为后续的操作往往大部分是rpc调用，方法执行时间相对较长。另外对于下单支付这个操作，3和4是后续业务的需要，在设计上不能和下单支付本身出现强耦合度。所以这里我们可以引入 MQ 解决，也就是说1和2执行完成后，生产者只需要通知下3和4，把后续的操作扔给消息队列，立即返回。这里的 MQ 起到的作用一个是异步调用，一个是解耦。</p><h3 id="nosql-非关系型数据库" tabindex="-1">NoSQL（非关系型数据库） <a class="header-anchor" href="#nosql-非关系型数据库" aria-label="Permalink to &quot;NoSQL（非关系型数据库）&quot;">​</a></h3><p>NoSQL 是所有非关系型数据库的统称，在分布式系统中用到很多，主要用来提高 QPS(query per second)。</p><p>Redis 常用作缓存，或者内存数据库，小巧强大，什么数据适合放在 Redis 也就是缓存中，一个是经常查询的，需要频繁磁盘 io 的，例如有个快件系统，有个需求是当快件状态为异常时候，需要发送邮件提醒给系统管理员。接口入参是快件id，通常做法我们需要拿到id，去数据库查状态，然后发送，但是快件基数很大时候每天的问题件也可能会很多，接口调用频繁时候就需要改进做法，这时我们可以把快件状态信息放在redis里面，key是快件id, value是快进状态，每次进入接口时候直接redis里面取status就可以，速度很快。另一个是查询数据缓慢的，可以放在缓存中。</p>',37),l=[i];function p(s,n,h,c,d,u){return r(),e("div",null,l)}const g=a(o,[["render",p]]);export{P as __pageData,g as default};
